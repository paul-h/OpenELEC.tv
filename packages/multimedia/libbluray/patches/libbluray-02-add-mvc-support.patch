diff --git a/Makefile.am b/Makefile.am
index 300deec..5c77a05 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -186,10 +186,12 @@ endif
 
 
 if USING_BDJAVA
+if USING_BDJAVA_BUILD_JAR
 jardir=$(datadir)/java/
 jar_DATA=$(top_builddir)/.libs/libbluray-$(BDJ_TYPE)-$(VERSION).jar
 
 $(top_builddir)/.libs/libbluray-$(BDJ_TYPE)-$(VERSION).jar: all-local
+endif
 
 libbluray_la_SOURCES += \
 	src/libbluray/bdj/bdj.h \
@@ -214,6 +216,7 @@ libbluray_la_SOURCES += \
 
 AM_CFLAGS += $(BDJAVA_CFLAGS)
 
+if USING_BDJAVA_BUILD_JAR
 all-local:
 	ant -f $(top_srcdir)/src/libbluray/bdj/build.xml \
 	    -Dbuild='$(abs_builddir)/src/libbluray/bdj/build' \
@@ -229,6 +232,7 @@ clean-local:
 	    -Dversion='$(BDJ_TYPE)-$(VERSION)' \
 	    clean
 endif
+endif
 
 pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = src/libbluray.pc
@@ -266,20 +270,20 @@ bd_info_LDADD = libbluray.la
 bdsplice_SOURCES = src/examples/bdsplice.c
 bdsplice_LDADD = libbluray.la
 
-bdj_test_SOURCES = src/examples/bdj_test.c
+bdj_test_SOURCES = src/devtools/bdj_test.c
 bdj_test_LDADD = libbluray.la
 
-bdjo_dump_SOURCES = src/examples/bdjo_dump.c
+bdjo_dump_SOURCES = src/devtools/bdjo_dump.c
 bdjo_dump_LDADD = libbluray.la
 
 clpi_dump_CFLAGS = $(AM_CFLAGS)
 clpi_dump_SOURCES = \
-	src/examples/clpi_dump.c \
-	src/examples/util.c \
-	src/examples/util.h
+	src/devtools/clpi_dump.c \
+	src/devtools/util.c \
+	src/devtools/util.h
 clpi_dump_LDADD = libbluray.la
 
-hdmv_test_SOURCES = src/examples/hdmv_test.c
+hdmv_test_SOURCES = src/devtools/hdmv_test.c
 hdmv_test_LDADD = libbluray.la
 
 index_dump_SOURCES = src/examples/index_dump.c
@@ -292,15 +296,15 @@ list_titles_SOURCES = src/examples/list_titles.c
 list_titles_LDADD = libbluray.la
 
 mobj_dump_CFLAGS = $(AM_CFLAGS)
-mobj_dump_SOURCES = src/examples/mobj_dump.c \
+mobj_dump_SOURCES = src/devtools/mobj_dump.c \
 	src/libbluray/hdmv/mobj_print.c
 mobj_dump_LDADD = libbluray.la
 
 mpls_dump_CFLAGS = $(AM_CFLAGS)
 mpls_dump_SOURCES = \
-	src/examples/mpls_dump.c \
-	src/examples/util.c \
-	src/examples/util.h
+	src/devtools/mpls_dump.c \
+	src/devtools/util.c \
+	src/devtools/util.h
 mpls_dump_LDADD = libbluray.la
 
 sound_dump_SOURCES = src/examples/sound_dump.c
diff --git a/config.h b/config.h
new file mode 100644
index 0000000..6764704
--- /dev/null
+++ b/config.h
@@ -0,0 +1,157 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if libudfread is to be used for disc image access */
+/* #undef ENABLE_UDF */
+
+/* Define to 1 if using libbluray J2ME stack */
+/* #undef HAVE_BDJ_J2ME */
+
+/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
+   */
+/* #undef HAVE_DIRENT_H */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+/* #undef HAVE_DLFCN_H */
+
+/* Define to 1 if you have the <errno.h> header file. */
+#define HAVE_ERRNO_H 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+/* #undef HAVE_FCNTL_H */
+
+/* Define this if you have fontconfig library */
+/* #undef HAVE_FONTCONFIG */
+
+/* Define this if you have FreeType2 library */
+/* #undef HAVE_FT2 */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <jni.h> header file. */
+/* #undef HAVE_JNI_H */
+
+/* Define to 1 if you have the <libgen.h> header file. */
+#define HAVE_LIBGEN_H 1
+
+/* Define to 1 if libxml2 is to be used for metadata parsing */
+/* #undef HAVE_LIBXML2 */
+
+/* Define to 1 if you have the <linux/cdrom.h> header file. */
+/* #undef HAVE_LINUX_CDROM_H */
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#define HAVE_MALLOC_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <mntent.h> header file. */
+/* #undef HAVE_MNTENT_H */
+
+/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
+/* #undef HAVE_NDIR_H */
+
+/* Define to 1 if you have the <pthread.h> header file. */
+/* #undef HAVE_PTHREAD_H */
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#define HAVE_STDARG_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+/* #undef HAVE_STRINGS_H */
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if `d_type' is a member of `struct dirent'. */
+/* #undef HAVE_STRUCT_DIRENT_D_TYPE */
+
+/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
+   */
+/* #undef HAVE_SYS_DIR_H */
+
+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
+   */
+/* #undef HAVE_SYS_NDIR_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <time.h> header file. */
+#define HAVE_TIME_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+/* #undef HAVE_UNISTD_H */
+
+/* "Defines the architecture of the java vm." */
+/* #undef JAVA_ARCH */
+
+/* "" */
+/* #undef JDK_HOME */
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR ".libs/"
+
+/* Name of package */
+#define PACKAGE "libbluray"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "http://www.videolan.org/developers/libbluray.html"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "libbluray"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "libbluray 0.9.2"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "libbluray"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "0.9.2"
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#define RETSIGTYPE void
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* "Define to 1 if using BD-Java" */
+/* #undef USING_BDJAVA */
+
+/* Version number of package */
+#define VERSION "0.9.2"
+
+/* Enable large inode numbers on Mac OS X 10.5.  */
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
+#endif
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+#define _FILE_OFFSET_BITS 64
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to '0x0501' for IE 5.01. */
+#define _WIN32_IE 0x0501
+
+/* Define to '0x0502' for Windows XP SP2 APIs. */
+#define _WIN32_WINNT 0x0502
diff --git a/configure.ac b/configure.ac
index e0da375..ed08c96 100644
--- a/configure.ac
+++ b/configure.ac
@@ -87,7 +87,15 @@ AC_ARG_ENABLE([bdjava],
   [use_bdjava=yes])
 
 AC_ARG_ENABLE([udf],
-  [AS_HELP_STRING([--enable-udf], [enable UDF support @<:@default=disabled@:>@])])
+  [AS_HELP_STRING([--disable-udf], [disable UDF support @<:@default=enabled@:>@])],
+  [enable_udf=$enableval],
+  [enable_udf=yes])
+
+AC_ARG_ENABLE([bdjava-jar],
+  [AS_HELP_STRING([--disable-bdjava-jar],
+  [disable building of BD-Java JAR file @<:@default=enabled@:>@])],
+  [use_bdjava_jar=$enableval],
+  [use_bdjava_jar=yes])
 
 AC_ARG_WITH([libxml2],
   [AS_HELP_STRING([--without-libxml2], [build without libxml2 support @<:@default=with@:>@])])
@@ -224,7 +232,7 @@ if [[ $use_bdjava = "yes" ]]; then
   ])
 
   AC_CHECK_PROG(HAVE_ANT, [ant], yes, no)
-  if test "x$HAVE_ANT" = "xno"; then
+  if test "x$use_bdjava_jar" = "xyes" && test "x$HAVE_ANT" = "xno"; then
       AC_MSG_ERROR([BD-J requires ANT, but ant was not found. Please install it.])
   fi
 
@@ -233,6 +241,7 @@ if [[ $use_bdjava = "yes" ]]; then
   AC_DEFINE_UNQUOTED([JDK_HOME], ["$JDK_HOME"], [""])
 fi
 AM_CONDITIONAL([USING_BDJAVA], [ test $use_bdjava = "yes" ])
+AM_CONDITIONAL([USING_BDJAVA_BUILD_JAR], [ test $use_bdjava_jar = "yes" ])
 
 dnl BD-J type
 if test "$BDJ_TYPE" = "j2me"; then
@@ -292,6 +301,7 @@ echo "  --------"
 echo "  BD-J support:                  $use_bdjava"
 if [[ $use_bdjava = "yes" ]]; then
 echo "  BD-J type:                     $BDJ_TYPE"
+echo "  build JAR:                     $use_bdjava_jar"
 if test x"$BDJ_BOOTCLASSPATH" != x""; then
 echo "  BD-J bootclasspath:            $BDJ_BOOTCLASSPATH"
 fi
diff --git a/includes/inttypes.h b/includes/inttypes.h
new file mode 100644
index 0000000..ead903f
--- /dev/null
+++ b/includes/inttypes.h
@@ -0,0 +1,305 @@
+// ISO C9x  compliant inttypes.h for Microsoft Visual Studio
+// Based on ISO/IEC 9899:TC2 Committee draft (May 6, 2005) WG14/N1124
+//
+//  Copyright (c) 2006 Alexander Chemeris
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+//   1. Redistributions of source code must retain the above copyright notice,
+//      this list of conditions and the following disclaimer.
+//
+//   2. Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//
+//   3. The name of the author may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+// EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _MSC_VER // [
+#error "Use this header only with Microsoft Visual C++ compilers!"
+#endif // _MSC_VER ]
+
+#ifndef _MSC_INTTYPES_H_ // [
+#define _MSC_INTTYPES_H_
+
+#if _MSC_VER > 1000
+#pragma once
+#endif
+
+#include "stdint.h"
+
+// 7.8 Format conversion of integer types
+
+typedef struct {
+   intmax_t quot;
+   intmax_t rem;
+} imaxdiv_t;
+
+// 7.8.1 Macros for format specifiers
+
+#if !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS) // [   See footnote 185 at page 198
+
+// The fprintf macros for signed integers are:
+#define PRId8       "d"
+#define PRIi8       "i"
+#define PRIdLEAST8  "d"
+#define PRIiLEAST8  "i"
+#define PRIdFAST8   "d"
+#define PRIiFAST8   "i"
+
+#define PRId16       "hd"
+#define PRIi16       "hi"
+#define PRIdLEAST16  "hd"
+#define PRIiLEAST16  "hi"
+#define PRIdFAST16   "hd"
+#define PRIiFAST16   "hi"
+
+#define PRId32       "I32d"
+#define PRIi32       "I32i"
+#define PRIdLEAST32  "I32d"
+#define PRIiLEAST32  "I32i"
+#define PRIdFAST32   "I32d"
+#define PRIiFAST32   "I32i"
+
+#define PRId64       "I64d"
+#define PRIi64       "I64i"
+#define PRIdLEAST64  "I64d"
+#define PRIiLEAST64  "I64i"
+#define PRIdFAST64   "I64d"
+#define PRIiFAST64   "I64i"
+
+#define PRIdMAX     "I64d"
+#define PRIiMAX     "I64i"
+
+#define PRIdPTR     "Id"
+#define PRIiPTR     "Ii"
+
+// The fprintf macros for unsigned integers are:
+#define PRIo8       "o"
+#define PRIu8       "u"
+#define PRIx8       "x"
+#define PRIX8       "X"
+#define PRIoLEAST8  "o"
+#define PRIuLEAST8  "u"
+#define PRIxLEAST8  "x"
+#define PRIXLEAST8  "X"
+#define PRIoFAST8   "o"
+#define PRIuFAST8   "u"
+#define PRIxFAST8   "x"
+#define PRIXFAST8   "X"
+
+#define PRIo16       "ho"
+#define PRIu16       "hu"
+#define PRIx16       "hx"
+#define PRIX16       "hX"
+#define PRIoLEAST16  "ho"
+#define PRIuLEAST16  "hu"
+#define PRIxLEAST16  "hx"
+#define PRIXLEAST16  "hX"
+#define PRIoFAST16   "ho"
+#define PRIuFAST16   "hu"
+#define PRIxFAST16   "hx"
+#define PRIXFAST16   "hX"
+
+#define PRIo32       "I32o"
+#define PRIu32       "I32u"
+#define PRIx32       "I32x"
+#define PRIX32       "I32X"
+#define PRIoLEAST32  "I32o"
+#define PRIuLEAST32  "I32u"
+#define PRIxLEAST32  "I32x"
+#define PRIXLEAST32  "I32X"
+#define PRIoFAST32   "I32o"
+#define PRIuFAST32   "I32u"
+#define PRIxFAST32   "I32x"
+#define PRIXFAST32   "I32X"
+
+#define PRIo64       "I64o"
+#define PRIu64       "I64u"
+#define PRIx64       "I64x"
+#define PRIX64       "I64X"
+#define PRIoLEAST64  "I64o"
+#define PRIuLEAST64  "I64u"
+#define PRIxLEAST64  "I64x"
+#define PRIXLEAST64  "I64X"
+#define PRIoFAST64   "I64o"
+#define PRIuFAST64   "I64u"
+#define PRIxFAST64   "I64x"
+#define PRIXFAST64   "I64X"
+
+#define PRIoMAX     "I64o"
+#define PRIuMAX     "I64u"
+#define PRIxMAX     "I64x"
+#define PRIXMAX     "I64X"
+
+#define PRIoPTR     "Io"
+#define PRIuPTR     "Iu"
+#define PRIxPTR     "Ix"
+#define PRIXPTR     "IX"
+
+// The fscanf macros for signed integers are:
+#define SCNd8       "d"
+#define SCNi8       "i"
+#define SCNdLEAST8  "d"
+#define SCNiLEAST8  "i"
+#define SCNdFAST8   "d"
+#define SCNiFAST8   "i"
+
+#define SCNd16       "hd"
+#define SCNi16       "hi"
+#define SCNdLEAST16  "hd"
+#define SCNiLEAST16  "hi"
+#define SCNdFAST16   "hd"
+#define SCNiFAST16   "hi"
+
+#define SCNd32       "ld"
+#define SCNi32       "li"
+#define SCNdLEAST32  "ld"
+#define SCNiLEAST32  "li"
+#define SCNdFAST32   "ld"
+#define SCNiFAST32   "li"
+
+#define SCNd64       "I64d"
+#define SCNi64       "I64i"
+#define SCNdLEAST64  "I64d"
+#define SCNiLEAST64  "I64i"
+#define SCNdFAST64   "I64d"
+#define SCNiFAST64   "I64i"
+
+#define SCNdMAX     "I64d"
+#define SCNiMAX     "I64i"
+
+#ifdef _WIN64 // [
+#  define SCNdPTR     "I64d"
+#  define SCNiPTR     "I64i"
+#else  // _WIN64 ][
+#  define SCNdPTR     "ld"
+#  define SCNiPTR     "li"
+#endif  // _WIN64 ]
+
+// The fscanf macros for unsigned integers are:
+#define SCNo8       "o"
+#define SCNu8       "u"
+#define SCNx8       "x"
+#define SCNX8       "X"
+#define SCNoLEAST8  "o"
+#define SCNuLEAST8  "u"
+#define SCNxLEAST8  "x"
+#define SCNXLEAST8  "X"
+#define SCNoFAST8   "o"
+#define SCNuFAST8   "u"
+#define SCNxFAST8   "x"
+#define SCNXFAST8   "X"
+
+#define SCNo16       "ho"
+#define SCNu16       "hu"
+#define SCNx16       "hx"
+#define SCNX16       "hX"
+#define SCNoLEAST16  "ho"
+#define SCNuLEAST16  "hu"
+#define SCNxLEAST16  "hx"
+#define SCNXLEAST16  "hX"
+#define SCNoFAST16   "ho"
+#define SCNuFAST16   "hu"
+#define SCNxFAST16   "hx"
+#define SCNXFAST16   "hX"
+
+#define SCNo32       "lo"
+#define SCNu32       "lu"
+#define SCNx32       "lx"
+#define SCNX32       "lX"
+#define SCNoLEAST32  "lo"
+#define SCNuLEAST32  "lu"
+#define SCNxLEAST32  "lx"
+#define SCNXLEAST32  "lX"
+#define SCNoFAST32   "lo"
+#define SCNuFAST32   "lu"
+#define SCNxFAST32   "lx"
+#define SCNXFAST32   "lX"
+
+#define SCNo64       "I64o"
+#define SCNu64       "I64u"
+#define SCNx64       "I64x"
+#define SCNX64       "I64X"
+#define SCNoLEAST64  "I64o"
+#define SCNuLEAST64  "I64u"
+#define SCNxLEAST64  "I64x"
+#define SCNXLEAST64  "I64X"
+#define SCNoFAST64   "I64o"
+#define SCNuFAST64   "I64u"
+#define SCNxFAST64   "I64x"
+#define SCNXFAST64   "I64X"
+
+#define SCNoMAX     "I64o"
+#define SCNuMAX     "I64u"
+#define SCNxMAX     "I64x"
+#define SCNXMAX     "I64X"
+
+#ifdef _WIN64 // [
+#  define SCNoPTR     "I64o"
+#  define SCNuPTR     "I64u"
+#  define SCNxPTR     "I64x"
+#  define SCNXPTR     "I64X"
+#else  // _WIN64 ][
+#  define SCNoPTR     "lo"
+#  define SCNuPTR     "lu"
+#  define SCNxPTR     "lx"
+#  define SCNXPTR     "lX"
+#endif  // _WIN64 ]
+
+#endif // __STDC_FORMAT_MACROS ]
+
+// 7.8.2 Functions for greatest-width integer types
+
+// 7.8.2.1 The imaxabs function
+#define imaxabs _abs64
+
+// 7.8.2.2 The imaxdiv function
+
+// This is modified version of div() function from Microsoft's div.c found
+// in %MSVC.NET%\crt\src\div.c
+#ifdef STATIC_IMAXDIV // [
+static
+#else // STATIC_IMAXDIV ][
+_inline
+#endif // STATIC_IMAXDIV ]
+imaxdiv_t __cdecl imaxdiv(intmax_t numer, intmax_t denom)
+{
+   imaxdiv_t result;
+
+   result.quot = numer / denom;
+   result.rem = numer % denom;
+
+   if (numer < 0 && result.rem > 0) {
+      // did division wrong; must fix up
+      ++result.quot;
+      result.rem -= denom;
+   }
+
+   return result;
+}
+
+// 7.8.2.3 The strtoimax and strtoumax functions
+#define strtoimax _strtoi64
+#define strtoumax _strtoui64
+
+// 7.8.2.4 The wcstoimax and wcstoumax functions
+#define wcstoimax _wcstoi64
+#define wcstoumax _wcstoui64
+
+
+#endif // _MSC_INTTYPES_H_ ]
diff --git a/libbluray.def b/libbluray.def
new file mode 100644
index 0000000..d4c93cb
--- /dev/null
+++ b/libbluray.def
@@ -0,0 +1,63 @@
+; libbluray.def ; declares the exports
+
+LIBRARY         "libbluray.dll"
+
+EXPORTS
+                ; bluray.h
+                bd_get_version
+                bd_get_titles
+                bd_get_title_info
+                bd_get_playlist_info
+                bd_free_title_info
+                bd_open
+                bd_close
+                bd_seek
+                bd_seek_time
+                bd_find_seek_point
+                bd_read
+                bd_read_skip_still
+                bd_seek_chapter
+                bd_chapter_pos
+                bd_get_current_chapter
+                bd_seek_mark
+                bd_seek_playitem
+                bd_select_playlist
+                bd_select_title
+                bd_select_angle
+                bd_seamless_angle_change
+                bd_get_title_size
+                bd_get_current_title
+                bd_get_current_angle
+                bd_tell
+                bd_tell_time
+                bd_get_disc_info
+                bd_set_player_setting
+                bd_set_player_setting_str
+                bd_start_bdj
+                bd_stop_bdj
+                bd_get_event
+                bd_play
+                bd_read_ext
+                bd_play_title
+                bd_menu_call
+                bd_register_overlay_proc
+                bd_register_argb_overlay_proc
+                bd_set_scr
+                bd_user_input
+                bd_mouse_select
+                bd_get_sound_effect
+                bd_get_meta
+                bd_get_clpi
+                bd_read_clpi
+                bd_free_clpi
+                bd_read_mpls
+                bd_free_mpls
+                bd_read_mobj
+                bd_free_mobj
+                bd_get_clip_infos
+                bd_get_title_mpls
+
+                ; additional functions
+                bd_set_debug_handler
+                bd_set_debug_mask
+                bd_get_debug_mask
diff --git a/libbluray.vcxproj b/libbluray.vcxproj
new file mode 100644
index 0000000..c778955
--- /dev/null
+++ b/libbluray.vcxproj
@@ -0,0 +1,231 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="DebugRelease|Win32">
+      <Configuration>DebugRelease</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="DebugRelease|x64">
+      <Configuration>DebugRelease</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="src\file\dirs.h" />
+    <ClInclude Include="src\file\dl.h" />
+    <ClInclude Include="src\file\file.h" />
+    <ClInclude Include="src\file\filesystem.h" />
+    <ClInclude Include="src\file\mount.h" />
+    <ClInclude Include="src\libbluray\bdnav\bdid_parse.h" />
+    <ClInclude Include="src\libbluray\bdnav\bdparse.h" />
+    <ClInclude Include="src\libbluray\bdnav\clpi_data.h" />
+    <ClInclude Include="src\libbluray\bdnav\clpi_parse.h" />
+    <ClInclude Include="src\libbluray\bdnav\extdata_parse.h" />
+    <ClInclude Include="src\libbluray\bdnav\index_parse.h" />
+    <ClInclude Include="src\libbluray\bdnav\meta_data.h" />
+    <ClInclude Include="src\libbluray\bdnav\meta_parse.h" />
+    <ClInclude Include="src\libbluray\bdnav\mpls_parse.h" />
+    <ClInclude Include="src\libbluray\bdnav\navigation.h" />
+    <ClInclude Include="src\libbluray\bdnav\sound_parse.h" />
+    <ClInclude Include="src\libbluray\bdnav\uo_mask_table.h" />
+    <ClInclude Include="src\libbluray\bluray-version.h" />
+    <ClInclude Include="src\libbluray\bluray.h" />
+    <ClInclude Include="src\libbluray\bluray_internal.h" />
+    <ClInclude Include="src\libbluray\decoders\graphics_controller.h" />
+    <ClInclude Include="src\libbluray\decoders\graphics_processor.h" />
+    <ClInclude Include="src\libbluray\decoders\ig.h" />
+    <ClInclude Include="src\libbluray\decoders\ig_decode.h" />
+    <ClInclude Include="src\libbluray\decoders\m2ts_demux.h" />
+    <ClInclude Include="src\libbluray\decoders\m2ts_filter.h" />
+    <ClInclude Include="src\libbluray\decoders\overlay.h" />
+    <ClInclude Include="src\libbluray\decoders\pes_buffer.h" />
+    <ClInclude Include="src\libbluray\decoders\pg.h" />
+    <ClInclude Include="src\libbluray\decoders\pg_decode.h" />
+    <ClInclude Include="src\libbluray\decoders\rle.h" />
+    <ClInclude Include="src\libbluray\decoders\textst.h" />
+    <ClInclude Include="src\libbluray\decoders\textst_decode.h" />
+    <ClInclude Include="src\libbluray\decoders\textst_render.h" />
+    <ClInclude Include="src\libbluray\disc\aacs.h" />
+    <ClInclude Include="src\libbluray\disc\bdplus.h" />
+    <ClInclude Include="src\libbluray\disc\dec.h" />
+    <ClInclude Include="src\libbluray\disc\disc.h" />
+    <ClInclude Include="src\libbluray\disc\enc_info.h" />
+    <ClInclude Include="src\libbluray\hdmv\hdmv_insn.h" />
+    <ClInclude Include="src\libbluray\hdmv\hdmv_vm.h" />
+    <ClInclude Include="src\libbluray\hdmv\mobj_parse.h" />
+    <ClInclude Include="src\libbluray\keys.h" />
+    <ClInclude Include="src\libbluray\register.h" />
+    <ClInclude Include="src\util\array.h" />
+    <ClInclude Include="src\util\attributes.h" />
+    <ClInclude Include="src\util\bits.h" />
+    <ClInclude Include="src\util\logging.h" />
+    <ClInclude Include="src\util\log_control.h" />
+    <ClInclude Include="src\util\macro.h" />
+    <ClInclude Include="src\util\mutex.h" />
+    <ClInclude Include="src\util\refcnt.h" />
+    <ClInclude Include="src\util\strutl.h" />
+    <ClInclude Include="src\util\time.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\file\dirs_win32.c" />
+    <ClCompile Include="src\file\dir_win32.c" />
+    <ClCompile Include="src\file\dl_win32.c" />
+    <ClCompile Include="src\file\file.c" />
+    <ClCompile Include="src\file\filesystem.c" />
+    <ClCompile Include="src\file\file_win32.c" />
+    <ClCompile Include="src\file\mount.c" />
+    <ClCompile Include="src\libbluray\bdnav\bdid_parse.c" />
+    <ClCompile Include="src\libbluray\bdnav\clpi_parse.c" />
+    <ClCompile Include="src\libbluray\bdnav\extdata_parse.c" />
+    <ClCompile Include="src\libbluray\bdnav\index_parse.c" />
+    <ClCompile Include="src\libbluray\bdnav\meta_parse.c" />
+    <ClCompile Include="src\libbluray\bdnav\mpls_parse.c" />
+    <ClCompile Include="src\libbluray\bdnav\navigation.c" />
+    <ClCompile Include="src\libbluray\bdnav\sound_parse.c" />
+    <ClCompile Include="src\libbluray\bluray.c" />
+    <ClCompile Include="src\libbluray\decoders\graphics_controller.c" />
+    <ClCompile Include="src\libbluray\decoders\graphics_processor.c" />
+    <ClCompile Include="src\libbluray\decoders\ig_decode.c" />
+    <ClCompile Include="src\libbluray\decoders\m2ts_demux.c" />
+    <ClCompile Include="src\libbluray\decoders\m2ts_filter.c" />
+    <ClCompile Include="src\libbluray\decoders\pes_buffer.c" />
+    <ClCompile Include="src\libbluray\decoders\pg_decode.c" />
+    <ClCompile Include="src\libbluray\decoders\rle.c" />
+    <ClCompile Include="src\libbluray\decoders\textst_decode.c" />
+    <ClCompile Include="src\libbluray\decoders\textst_render.c" />
+    <ClCompile Include="src\libbluray\disc\aacs.c" />
+    <ClCompile Include="src\libbluray\disc\bdplus.c" />
+    <ClCompile Include="src\libbluray\disc\dec.c" />
+    <ClCompile Include="src\libbluray\disc\disc.c" />
+    <ClCompile Include="src\libbluray\hdmv\hdmv_vm.c" />
+    <ClCompile Include="src\libbluray\hdmv\mobj_parse.c" />
+    <ClCompile Include="src\libbluray\hdmv\mobj_print.c" />
+    <ClCompile Include="src\libbluray\register.c" />
+    <ClCompile Include="src\util\array.c" />
+    <ClCompile Include="src\util\bits.c" />
+    <ClCompile Include="src\util\logging.c" />
+    <ClCompile Include="src\util\mutex.c" />
+    <ClCompile Include="src\util\refcnt.c" />
+    <ClCompile Include="src\util\strutl.c" />
+    <ClCompile Include="src\util\time.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="libbluray.def" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{E1DA1B95-71F1-4C21-A271-121176925062}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>libbluray</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Label="Configuration" Condition="'$(VisualStudioVersion)' == '11.0'">
+    <PlatformToolset>v110_xp</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(VisualStudioVersion)' == '12.0'">
+    <PlatformToolset>v120_xp</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(VisualStudioVersion)' == '14.0'">
+    <PlatformToolset>v140_xp</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Debug' Or '$(Configuration)'=='DebugRelease'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)'=='Debug' Or '$(Configuration)'=='DebugRelease'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)bin_$(PlatformName)d\</OutDir>
+    <IntDir>$(SolutionDir)bin_$(PlatformName)d\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Release'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(SolutionDir)bin_$(PlatformName)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)bin_$(PlatformName)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug' Or '$(Configuration)'=='DebugRelease'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>HAVE_CONFIG_H;WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBBLURAY_EXPORTS;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PreprocessorDefinitions Condition="'$(VisualStudioVersion)' == '12.0'">__STDC_FORMAT_MACROS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)includes;$(ProjectDir)src;$(ProjectDir)src\libbluray;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <CompileAs Condition="'$(VisualStudioVersion)' == '12.0'">CompileAsCpp</CompileAs>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <ModuleDefinitionFile>libbluray.def</ModuleDefinitionFile>
+    </Link>
+    <PostBuildEvent>
+      <Command>xcopy /I /Y "$(OutDir)$(TargetName).lib" "$(OutDir)lib\"</Command>
+      <Message>Copy .lib into library path</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='DebugRelease'">
+    <ClCompile>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>HAVE_CONFIG_H;WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBBLURAY_EXPORTS;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PreprocessorDefinitions Condition="'$(VisualStudioVersion)' == '12.0'">__STDC_FORMAT_MACROS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)includes;$(ProjectDir)src;$(ProjectDir)src\libbluray;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <EnableEnhancedInstructionSet Condition="'$(Platform)'=='Win32'">StreamingSIMDExtensions</EnableEnhancedInstructionSet>
+      <CompileAs Condition="'$(VisualStudioVersion)' == '12.0'">CompileAsCpp</CompileAs>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <ModuleDefinitionFile>libbluray.def</ModuleDefinitionFile>
+      <SetChecksum>true</SetChecksum>
+    </Link>
+    <PostBuildEvent>
+      <Command>xcopy /I /Y "$(TargetDir)$(TargetName)$(TargetExt)" "$(OutDir)..\"
+xcopy /I /Y "$(TargetDir)$(TargetName).lib" "$(OutDir)..\lib\"</Command>
+      <Message>Copy .dll/.lib into library path</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/libbluray.vcxproj.filters b/libbluray.vcxproj.filters
new file mode 100644
index 0000000..57ff16c
--- /dev/null
+++ b/libbluray.vcxproj.filters
@@ -0,0 +1,353 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Source Files\util">
+      <UniqueIdentifier>{1ab0e905-7c04-4090-b385-6363dd1c961c}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\util">
+      <UniqueIdentifier>{b8fa3348-a089-461f-9ef5-3d9df997b8e5}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\file">
+      <UniqueIdentifier>{125333e9-0b5e-45f9-a444-f0aaaf547d9b}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\file">
+      <UniqueIdentifier>{a743058f-f07a-4d0f-bab6-02dc57defda9}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\libbluray">
+      <UniqueIdentifier>{7dacc7c4-ef59-452b-9e5b-392c9df07c98}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\libbluray">
+      <UniqueIdentifier>{c7895c81-c186-4d5e-a8ff-645c6d55a731}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\libbluray\bdnav">
+      <UniqueIdentifier>{c8619466-211b-4c85-9d30-d1b1a822d32e}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\libbluray\bdnav">
+      <UniqueIdentifier>{8afb6919-994f-4d1f-9638-ce4a06d0b473}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\libbluray\decoders">
+      <UniqueIdentifier>{0e9086a7-eebf-4b8e-a4fe-b1724d148877}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\libbluray\decoders">
+      <UniqueIdentifier>{fc5e776b-0f32-493a-b823-240288288502}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\libbluray\hdmv">
+      <UniqueIdentifier>{96d2d786-cd45-4856-937d-9e6f85ced241}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\libbluray\hdmv">
+      <UniqueIdentifier>{9f4ea4ae-217a-4d97-a5f3-e561ce1e49cd}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\libbluray\disc">
+      <UniqueIdentifier>{09e1b1b8-3aa3-4918-b157-3dfc0554ccbb}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\libbluray\disc">
+      <UniqueIdentifier>{1e02e503-752e-4765-9dfb-8cc67a7b79f8}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="src\util\attributes.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="src\util\strutl.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="src\util\bits.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="src\util\log_control.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="src\util\logging.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="src\util\macro.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="src\util\mutex.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="src\file\dl.h">
+      <Filter>Header Files\file</Filter>
+    </ClInclude>
+    <ClInclude Include="src\file\filesystem.h">
+      <Filter>Header Files\file</Filter>
+    </ClInclude>
+    <ClInclude Include="src\file\file.h">
+      <Filter>Header Files\file</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\bluray.h">
+      <Filter>Header Files\libbluray</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\register.h">
+      <Filter>Header Files\libbluray</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\keys.h">
+      <Filter>Header Files\libbluray</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\bdnav\bdparse.h">
+      <Filter>Header Files\libbluray\bdnav</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\bdnav\uo_mask_table.h">
+      <Filter>Header Files\libbluray\bdnav</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\bdnav\clpi_parse.h">
+      <Filter>Header Files\libbluray\bdnav</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\bdnav\index_parse.h">
+      <Filter>Header Files\libbluray\bdnav</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\bdnav\meta_data.h">
+      <Filter>Header Files\libbluray\bdnav</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\bdnav\meta_parse.h">
+      <Filter>Header Files\libbluray\bdnav</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\bdnav\mpls_parse.h">
+      <Filter>Header Files\libbluray\bdnav</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\bdnav\navigation.h">
+      <Filter>Header Files\libbluray\bdnav</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\bdnav\sound_parse.h">
+      <Filter>Header Files\libbluray\bdnav</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\decoders\graphics_controller.h">
+      <Filter>Header Files\libbluray\decoders</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\decoders\pg_decode.h">
+      <Filter>Header Files\libbluray\decoders</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\decoders\graphics_processor.h">
+      <Filter>Header Files\libbluray\decoders</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\decoders\ig.h">
+      <Filter>Header Files\libbluray\decoders</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\decoders\ig_decode.h">
+      <Filter>Header Files\libbluray\decoders</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\decoders\m2ts_demux.h">
+      <Filter>Header Files\libbluray\decoders</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\decoders\overlay.h">
+      <Filter>Header Files\libbluray\decoders</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\decoders\pes_buffer.h">
+      <Filter>Header Files\libbluray\decoders</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\decoders\pg.h">
+      <Filter>Header Files\libbluray\decoders</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\hdmv\hdmv_insn.h">
+      <Filter>Header Files\libbluray\hdmv</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\hdmv\mobj_parse.h">
+      <Filter>Header Files\libbluray\hdmv</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\hdmv\hdmv_vm.h">
+      <Filter>Header Files\libbluray\hdmv</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\bdnav\bdid_parse.h">
+      <Filter>Header Files\libbluray\bdnav</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\bdnav\clpi_data.h">
+      <Filter>Header Files\libbluray\bdnav</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\bdnav\extdata_parse.h">
+      <Filter>Header Files\libbluray\bdnav</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\decoders\textst.h">
+      <Filter>Header Files\libbluray\decoders</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\decoders\textst_render.h">
+      <Filter>Header Files\libbluray\decoders</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\decoders\textst_decode.h">
+      <Filter>Header Files\libbluray\decoders</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\decoders\rle.h">
+      <Filter>Header Files\libbluray\decoders</Filter>
+    </ClInclude>
+    <ClInclude Include="src\util\refcnt.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="src\util\time.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\bluray_internal.h">
+      <Filter>Header Files\libbluray</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\decoders\m2ts_filter.h">
+      <Filter>Header Files\libbluray\decoders</Filter>
+    </ClInclude>
+    <ClInclude Include="src\file\dirs.h">
+      <Filter>Header Files\file</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\bluray-version.h">
+      <Filter>Header Files\libbluray</Filter>
+    </ClInclude>
+    <ClInclude Include="src\util\array.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\disc\aacs.h">
+      <Filter>Header Files\libbluray\disc</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\disc\bdplus.h">
+      <Filter>Header Files\libbluray\disc</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\disc\dec.h">
+      <Filter>Header Files\libbluray\disc</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\disc\disc.h">
+      <Filter>Header Files\libbluray\disc</Filter>
+    </ClInclude>
+    <ClInclude Include="src\libbluray\disc\enc_info.h">
+      <Filter>Header Files\libbluray\disc</Filter>
+    </ClInclude>
+    <ClInclude Include="src\file\mount.h">
+      <Filter>Header Files\file</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\util\logging.c">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="src\util\strutl.c">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="src\file\filesystem.c">
+      <Filter>Source Files\file</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\bluray.c">
+      <Filter>Source Files\libbluray</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\register.c">
+      <Filter>Source Files\libbluray</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\bdnav\clpi_parse.c">
+      <Filter>Source Files\libbluray\bdnav</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\bdnav\sound_parse.c">
+      <Filter>Source Files\libbluray\bdnav</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\bdnav\index_parse.c">
+      <Filter>Source Files\libbluray\bdnav</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\bdnav\meta_parse.c">
+      <Filter>Source Files\libbluray\bdnav</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\bdnav\mpls_parse.c">
+      <Filter>Source Files\libbluray\bdnav</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\bdnav\navigation.c">
+      <Filter>Source Files\libbluray\bdnav</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\decoders\graphics_controller.c">
+      <Filter>Source Files\libbluray\decoders</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\decoders\pg_decode.c">
+      <Filter>Source Files\libbluray\decoders</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\decoders\graphics_processor.c">
+      <Filter>Source Files\libbluray\decoders</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\decoders\ig_decode.c">
+      <Filter>Source Files\libbluray\decoders</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\decoders\m2ts_demux.c">
+      <Filter>Source Files\libbluray\decoders</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\decoders\pes_buffer.c">
+      <Filter>Source Files\libbluray\decoders</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\hdmv\hdmv_vm.c">
+      <Filter>Source Files\libbluray\hdmv</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\hdmv\mobj_print.c">
+      <Filter>Source Files\libbluray\hdmv</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\hdmv\mobj_parse.c">
+      <Filter>Source Files\libbluray\hdmv</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\bdnav\bdid_parse.c">
+      <Filter>Source Files\libbluray\bdnav</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\bdnav\extdata_parse.c">
+      <Filter>Source Files\libbluray\bdnav</Filter>
+    </ClCompile>
+    <ClCompile Include="src\util\bits.c">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="src\file\dir_win32.c">
+      <Filter>Source Files\file</Filter>
+    </ClCompile>
+    <ClCompile Include="src\file\dirs_win32.c">
+      <Filter>Source Files\file</Filter>
+    </ClCompile>
+    <ClCompile Include="src\file\dl_win32.c">
+      <Filter>Source Files\file</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\decoders\textst_decode.c">
+      <Filter>Source Files\libbluray\decoders</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\decoders\textst_render.c">
+      <Filter>Source Files\libbluray\decoders</Filter>
+    </ClCompile>
+    <ClCompile Include="src\util\refcnt.c">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\decoders\m2ts_filter.c">
+      <Filter>Source Files\libbluray\decoders</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\decoders\rle.c">
+      <Filter>Source Files\libbluray\decoders</Filter>
+    </ClCompile>
+    <ClCompile Include="src\file\file_win32.c">
+      <Filter>Source Files\file</Filter>
+    </ClCompile>
+    <ClCompile Include="src\file\file.c">
+      <Filter>Source Files\file</Filter>
+    </ClCompile>
+    <ClCompile Include="src\util\array.c">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="src\util\mutex.c">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\disc\aacs.c">
+      <Filter>Source Files\libbluray\disc</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\disc\bdplus.c">
+      <Filter>Source Files\libbluray\disc</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\disc\dec.c">
+      <Filter>Source Files\libbluray\disc</Filter>
+    </ClCompile>
+    <ClCompile Include="src\libbluray\disc\disc.c">
+      <Filter>Source Files\libbluray\disc</Filter>
+    </ClCompile>
+    <ClCompile Include="src\util\time.c">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="src\file\mount.c">
+      <Filter>Source Files\file</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="libbluray.def">
+      <Filter>Source Files</Filter>
+    </None>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src/devtools/bdj_test.c b/src/devtools/bdj_test.c
new file mode 100644
index 0000000..d9ebd16
--- /dev/null
+++ b/src/devtools/bdj_test.c
@@ -0,0 +1,67 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2010  William Hahne
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * In addition, as a special exception, the copyright holders of libbluray
+ * gives permission to link the code of its release of libbluray with the
+ * OpenSSL project's "OpenSSL" library (or with modified versions of it
+ * that use the same license as the "OpenSSL" library), and distribute
+ * the linked executables.  You must obey the GNU General Public License
+ * in all respects for all of the code used other than "OpenSSL".  If you
+ * modify this file, you may extend this exception to your version of the
+ * file, but you are not obligated to do so.  If you do not wish to do
+ * so, delete this exception statement from your version.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "libbluray/bluray.h"
+
+#if defined(_WIN32)
+#include <windows.h>
+#define sleep(x) Sleep(x)
+#endif
+
+static void _usage(void) {
+    printf("Usage: [path to disc] [starting object]\n");
+}
+
+int main(int argc, char** argv)
+{
+    if (argc < 3) {
+        _usage();
+        return 0;
+    }
+
+    printf("%s %s\n", argv[1], argv[2]);
+
+    BLURAY* bd = bd_open(argv[1], NULL);
+
+    bd_get_titles(bd, TITLES_ALL, 0);
+
+    if (!bd_start_bdj(bd, argv[2])) {
+        printf("Failed to start BD-J application.\n");
+    } else {
+        while (1) { sleep(20); }
+        bd_stop_bdj(bd);
+    }
+
+    bd_close(bd);
+
+    return 0;
+}
diff --git a/src/devtools/bdjo_dump.c b/src/devtools/bdjo_dump.c
new file mode 100644
index 0000000..c9c8141
--- /dev/null
+++ b/src/devtools/bdjo_dump.c
@@ -0,0 +1,206 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2014  Petri Hintukainen <phintuka@users.sourceforge.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+#include "libbluray/bluray.h"
+#include "libbluray/bdj/bdjo_data.h"
+
+#include <stdio.h>
+#include <string.h>
+
+static const char *_yes_no(int i)
+{
+    return i > 0 ? "yes" : i < 0 ? "unknown" : "no";
+}
+
+static const char *_binding_str(int i)
+{
+    switch (i) {
+        case 0:  return "unbound";
+        case 1:  return "disc bound";
+        case 3:  return "title bound";
+        default: return "???";
+    }
+}
+
+static const char *_visibility_str(int i)
+{
+    switch (i) {
+        case 0:  return "none";
+        case 1:  return "applications";
+        case 2:  return "user";
+        default: return "???";
+    }
+}
+
+static void _terminal_info_print(const BDJO_TERMINAL_INFO *p)
+{
+    printf("Terminal Info:\n");
+    printf("    Default AWT font    : %s\n", p->default_font);
+    printf("    initial HaVi config : %d\n", p->initial_havi_config_id);
+    printf("    Menu call mask      : %d\n", p->menu_call_mask);
+    printf("    Title search mask   : %d\n", p->menu_call_mask);
+}
+
+static void _app_cache_item_print(const BDJO_APP_CACHE_ITEM *p)
+{
+    printf("    %3.3s: %s%s\n",
+           p->lang_code, p->ref_to_name,
+           p->type == 1 ? ".jar" : p->type == 2 ? "/" : " (unknown type)");
+}
+
+static void _app_cache_info_print(const BDJO_APP_CACHE_INFO *p)
+{
+    unsigned ii;
+
+    printf("Application cache info:\n");
+    for (ii = 0; ii < p->num_item; ii++) {
+        _app_cache_item_print(&p->item[ii]);
+    }
+}
+
+static void _accessible_playlists_print(const BDJO_ACCESSIBLE_PLAYLISTS *p)
+{
+    unsigned ii;
+
+    printf("Accessible playlists:\n");
+    printf("    Access to all       : %s\n", _yes_no(p->access_to_all_flag));
+    printf("    Autostart first     : %s\n", _yes_no(p->autostart_first_playlist_flag));
+
+    if (p->num_pl) {
+        printf("    Playlists           : %d\n", p->num_pl);
+        for (ii = 0; ii < p->num_pl; ii++) {
+            printf("        %s.mpls\n", p->pl[ii].name);
+        }
+    }
+}
+
+static void _app_profile_print(BDJO_APP_PROFILE *p)
+{
+    printf("        Profile %d Version %d.%d.%d\n",
+           p->profile_number, p->major_version, p->minor_version, p->micro_version);
+}
+
+static void _app_print(const BDJO_APP *p)
+{
+    unsigned ii;
+
+    printf("    Control code:       : %d (%s)\n", p->control_code,
+           p->control_code == 1 ? "autostart" : p->control_code == 2 ? "present" : "???");
+    printf("    Type                : %d (%s)\n", p->type,
+           p->type == 1 ? "BD-J App" : "???");
+    printf("    Organization ID     : %08X\n", p->org_id);
+    printf("    Application ID      : %04X\n", p->app_id);
+    printf("    Priority            : %d\n", p->priority);
+    printf("    Binding             : %d (%s)\n", p->binding, _binding_str(p->binding));
+    printf("    Visibility          : %d (%s)\n", p->visibility, _visibility_str(p->visibility));
+
+    if (p->num_profile) {
+        printf("    Profiles:\n");
+        for (ii = 0; ii < p->num_profile; ii++) {
+            _app_profile_print(&p->profile[ii]);
+        }
+    }
+
+    if (p->num_name) {
+        printf("    Names:\n");
+        for (ii = 0; ii < p->num_name; ii++) {
+            printf("        %s: %s\n", p->name[ii].lang, p->name[ii].name);
+        }
+    }
+
+    printf("    Base directory      : %s\n", p->base_dir);
+    printf("    Icon locator        : %s\n", p->icon_locator);
+    printf("    Icon flags          : 0x%04x\n", p->icon_flags);
+    printf("    Classpath extension : %s\n", p->classpath_extension);
+    printf("    Initial class       : %s\n", p->initial_class);
+    printf("    Parameters          : ");
+    for (ii = 0; ii < p->num_param; ii++) {
+        printf("%s ", p->param[ii].param);
+    }
+    printf("\n");
+}
+
+static void _app_management_table_print(const BDJO_APP_MANAGEMENT_TABLE *p)
+{
+    unsigned ii;
+
+    for (ii = 0; ii < p->num_app; ii++) {
+        printf("Application %u:\n", ii);
+        _app_print(&p->app[ii]);
+    }
+}
+
+static void _key_interest_table_print(const BDJO_KEY_INTEREST_TABLE *p)
+{
+    unsigned int v;
+    memcpy(&v, p, sizeof(unsigned int));
+    if (v) {
+        printf("Key interest table:\n");
+        printf("    %s%s%s%s%s%s%s%s%s%s%s\n",
+               p->vk_play              ? "VK_PLAY " : "",
+               p->vk_stop              ? "VK_STOP " : "",
+               p->vk_ffw               ? "VK_FFW " : "",
+               p->vk_rew               ? "VK_REW " : "",
+               p->vk_track_next        ? "VK_TRACK_NEXT " : "",
+               p->vk_track_prev        ? "VK_TRACK_PREV " : "",
+               p->vk_pause             ? "VK_PAUSE " : "",
+               p->vk_still_off         ? "VK_STILL_OFF " : "",
+               p->vk_sec_audio_ena_dis ? "VK_SEC_AUDIO " : "",
+               p->vk_sec_video_ena_dis ? "VK_SEC_VIDEO " : "",
+               p->pg_textst_ena_dis    ? "VK_PG_TEXTST " : "");
+    }
+}
+
+static void _file_access_info_print(const BDJO_FILE_ACCESS_INFO *p)
+{
+    printf("File access info:\n    %s\n",  p->path);
+}
+
+static void _bdjo_print(const BDJO *p)
+{
+    _terminal_info_print(&p->terminal_info);
+    _app_cache_info_print(&p->app_cache_info);
+    _accessible_playlists_print(&p->accessible_playlists);
+    _app_management_table_print(&p->app_table);
+    _key_interest_table_print(&p->key_interest_table);
+    _file_access_info_print(&p->file_access_info);
+}
+
+int main(int argc, const char *argv[])
+{
+    if (argc < 2) {
+        fprintf(stderr, "usage: %s <bdjo_file>\n", argv[0]);
+        return 1;
+    }
+
+    int cnt;
+    for (cnt = 1; cnt < argc; cnt++) {
+
+        printf("%s\n", argv[cnt]);
+
+        BDJO *bdjo = bd_read_bdjo(argv[cnt]);
+        if (bdjo) {
+            _bdjo_print(bdjo);
+            bd_free_bdjo(bdjo);
+        }
+        printf("\n");
+    }
+
+    return 0;
+}
diff --git a/src/devtools/clpi_dump.c b/src/devtools/clpi_dump.c
new file mode 100644
index 0000000..bd64783
--- /dev/null
+++ b/src/devtools/clpi_dump.c
@@ -0,0 +1,487 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2009-2010  John Stebbins
+ * Copyright (C) 2012-2013  Petri Hintukainen <phintuka@users.sourceforge.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <inttypes.h>
+
+#include "libbluray/bdnav/clpi_data.h"
+#include "libbluray/bluray.h"
+
+#include "util.h"
+
+static int verbose;
+
+typedef struct {
+    int value;
+    const char *str;
+} VALUE_MAP;
+
+static inline const char*
+_lookup_str(const VALUE_MAP *map, int val)
+{
+    int ii;
+
+    for (ii = 0; map[ii].str; ii++) {
+        if (val == map[ii].value) {
+            return map[ii].str;
+        }
+    }
+    return "?";
+}
+
+const VALUE_MAP codec_map[] = {
+    {0x01, "MPEG-1 Video"},
+    {0x02, "MPEG-2 Video"},
+    {0x03, "MPEG-1 Audio"},
+    {0x04, "MPEG-2 Audio"},
+    {0x80, "LPCM"},
+    {0x81, "AC-3"},
+    {0x82, "DTS"},
+    {0x83, "TrueHD"},
+    {0x84, "AC-3 Plus"},
+    {0x85, "DTS-HD"},
+    {0x86, "DTS-HD Master"},
+    {0xa1, "AC-3 Plus for secondary audio"},
+    {0xa2, "DTS-HD for secondary audio"},
+    {0xea, "VC-1"},
+    {0x1b, "H.264"},
+    {0x20, "H.264 MVC dep."},
+    {0x90, "Presentation Graphics"},
+    {0x91, "Presentation Graphics"},
+    {0x92, "Interactive Graphics"},
+    {0, NULL}
+};
+
+const VALUE_MAP video_format_map[] = {
+    {0, "Reserved"},
+    {1, "480i"},
+    {2, "576i"},
+    {3, "480p"},
+    {4, "1080i"},
+    {5, "720p"},
+    {6, "1080p"},
+    {7, "576p"},
+    {0, NULL}
+};
+
+const VALUE_MAP video_rate_map[] = {
+    {0, "Reserved1"},
+    {1, "23.976"},
+    {2, "24"},
+    {3, "25"},
+    {4, "29.97"},
+    {5, "Reserved2"},
+    {6, "50"},
+    {7, "59.94"},
+    {0, NULL}
+};
+
+const VALUE_MAP video_aspect_map[] = {
+    {0, "Reserved1"},
+    {1, "Reserved2"},
+    {2, "4:3"},
+    {3, "16:9"},
+    {0, NULL}
+};
+
+const VALUE_MAP audio_format_map[] = {
+    {0, "Reserved1"},
+    {1, "Mono"},
+    {2, "Reserved2"},
+    {3, "Stereo"},
+    {4, "Reserved3"},
+    {5, "Reserved4"},
+    {6, "Multi Channel"},
+    {12, "Combo"},
+    {0, NULL}
+};
+
+const VALUE_MAP audio_rate_map[] = {
+    {0, "Reserved1"},
+    {1, "48 Khz"},
+    {2, "Reserved2"},
+    {3, "Reserved3"},
+    {4, "96 Khz"},
+    {5, "192 Khz"},
+    {12, "48/192 Khz"},
+    {14, "48/96 Khz"},
+    {0, NULL}
+};
+
+const VALUE_MAP application_type_map[] = {
+    {1, "Main TS for a main-path of Movie"},
+    {2, "Main TS for a main-path of Time based slide show"},
+    {3, "Main TS for a main-path of Browsable slide show"},
+    {4, "Sub TS for a sub-path of Browsable slide show"},
+    {5, "Sub TS for a sub-path of Interactive Graphics menu"},
+    {6, "Sub TS for a sub-path of Text subtitle"},
+    {7, "Sub TS for a sub-path of one or more elementary streams path"},
+    {0, NULL},
+};
+
+static void
+_show_stream(CLPI_PROG_STREAM *ss, int level)
+{
+    indent_printf(level, "Codec (%04x): %s", ss->coding_type,
+                    _lookup_str(codec_map, ss->coding_type));
+    indent_printf(level, "PID: %04x", ss->pid);
+    switch (ss->coding_type) {
+        case 0x01:
+        case 0x02:
+        case 0xea:
+        case 0x1b:
+        case 0x20:
+            indent_printf(level, "Format %02x: %s", ss->format,
+                        _lookup_str(video_format_map, ss->format));
+            indent_printf(level, "Rate %02x: %s", ss->rate,
+                        _lookup_str(video_rate_map, ss->rate));
+            indent_printf(level, "Aspect %02x: %s", ss->aspect,
+                        _lookup_str(video_aspect_map, ss->aspect));
+            indent_printf(level, "oc_flag %02x", ss->oc_flag);
+            break;
+
+        case 0x03:
+        case 0x04:
+        case 0x80:
+        case 0x81:
+        case 0x82:
+        case 0x83:
+        case 0x84:
+        case 0x85:
+        case 0x86:
+        case 0xa1:
+        case 0xa2:
+            indent_printf(level, "Format %02x: %s", ss->format,
+                        _lookup_str(audio_format_map, ss->format));
+            indent_printf(level, "Rate %02x: %s", ss->rate,
+                        _lookup_str(audio_rate_map, ss->rate));
+            indent_printf(level, "Language: %s", ss->lang);
+            break;
+
+        case 0x90:
+        case 0x91:
+        case 0xa0:
+            indent_printf(level, "Language: %s", ss->lang);
+            break;
+
+        case 0x92:
+            indent_printf(level, "Char Code: %02x", ss->char_code);
+            indent_printf(level, "Language: %s", ss->lang);
+            break;
+
+        default:
+            fprintf(stderr, "unrecognized coding type %02x\n", ss->coding_type);
+            break;
+    };
+}
+
+static void
+_show_clip_info(CLPI_CL *cl, int level)
+{
+    CLPI_CLIP_INFO *ci = &cl->clip;
+    int ii;
+
+    indent_printf(level, "Clip Info");
+    indent_printf(level+1, "Clip Stream Type: %02x", ci->clip_stream_type);
+    indent_printf(level+1, "Clip Application Type (%02x): %s",
+                  ci->application_type, _lookup_str(application_type_map, ci->application_type));
+    indent_printf(level+1, "is_ATC_delta: %s", ci->is_atc_delta ? "True" : "False");
+    indent_printf(level+1, "ATC delta count: %d", ci->atc_delta_count);
+    indent_printf(level+1, "TS Recording Rate: %u", ci->ts_recording_rate);
+    indent_printf(level+1, "Number Source Packets: %u", ci->num_source_packets);
+    // Show ts type info
+    indent_printf(level+1, "TS Type Info");
+    indent_printf(level+2, "Validity Flags %02x", ci->ts_type_info.validity);
+    indent_printf(level+2, "Format Id %s", ci->ts_type_info.format_id);
+    // Show cc5 thing
+    for (ii = 0; ii < ci->atc_delta_count; ii++) {
+        indent_printf(level+1, "ATC delta[ %d ]", ii);
+        indent_printf(level+2, "Delta %08x", ci->atc_delta[ii].delta);
+        indent_printf(level+2, "File Id %s", ci->atc_delta[ii].file_id);
+        indent_printf(level+2, "File Code %s", ci->atc_delta[ii].file_code);
+    }
+    // show fonts
+    if (cl->font_info.font_count) {
+        indent_printf(level+1, "Font files");
+        for (ii = 0; ii < cl->font_info.font_count; ii++) {
+            indent_printf(level+2, "Font file %d: %s.otf", ii+1, cl->font_info.font[ii].file_id);
+        }
+    }
+
+    printf("\n");
+}
+
+static void
+_show_seq_info(CLPI_SEQ_INFO *si, int level)
+{
+    CLPI_ATC_SEQ *atc;
+    CLPI_STC_SEQ *stc;
+    int ii, jj;
+
+    indent_printf(level, "Sequence Info");
+    indent_printf(level+1, "Number ATC Sequences: %d", si->num_atc_seq);
+    for (ii = 0; ii < si->num_atc_seq; ii++) {
+        atc = &si->atc_seq[ii];
+        indent_printf(level+1, "ATC Sequence %d", ii);
+        indent_printf(level+2, "SPN ATC Start: %u", atc->spn_atc_start);
+        indent_printf(level+2, "Offset STC Id: %d", atc->offset_stc_id);
+        indent_printf(level+2, "Number STC Sequences: %d", atc->num_stc_seq);
+        for (jj = 0; jj < atc->num_stc_seq; jj++) {
+            stc = &atc->stc_seq[jj];
+            indent_printf(level+2, "ATC Sequence %d", jj);
+            indent_printf(level+3, "SPN STC Start: %u", stc->spn_stc_start);
+            indent_printf(level+3, "PCR PID: %04x", stc->pcr_pid);
+            indent_printf(level+3, "Presentation Start: %u", 
+                            stc->presentation_start_time);
+            indent_printf(level+3, "Presentation End: %u", 
+                            stc->presentation_end_time);
+        }
+    }
+}
+
+static void
+_show_prog_info(CLPI_PROG_INFO *pi, int level)
+{
+    CLPI_PROG *prog;
+    int ii, jj;
+
+    indent_printf(level, "Program Info");
+    indent_printf(level+1, "Number Programs: %d", pi->num_prog);
+    for (ii = 0; ii < pi->num_prog; ii++) {
+        prog = &pi->progs[ii];
+        indent_printf(level+1, "Program %d", ii);
+        indent_printf(level+2, "SPN Program Sequence Start: %d", 
+                        prog->spn_program_sequence_start);
+        indent_printf(level+2, "Program Map PID: %d", prog->program_map_pid);
+        indent_printf(level+2, "Number Streams: %d", prog->num_streams);
+        indent_printf(level+2, "Number Groups: %d", prog->num_groups);
+        for (jj = 0; jj < prog->num_streams; jj++) {
+            indent_printf(level+2, "Stream %d", jj);
+            _show_stream(&prog->streams[jj], level+3);
+        }
+    }
+}
+
+static void
+_show_extent_start(CLPI_EXTENT_START *es, int level)
+{
+    unsigned int ii;
+
+    indent_printf(level, "Extension data: Extent Start Point");
+
+    if (!es->num_point) {
+        indent_printf(level+1, "(no data)");
+
+    } else {
+        indent_printf(level+1, "Number of Start Points: %d", es->num_point);
+
+        if (verbose) {
+            for (ii = 0; ii < es->num_point; ii++) {
+                indent_printf(level+1, "Extent %5d: SPN 0x%08X", ii, es->point[ii]);
+            }
+        }
+    }
+}
+
+static void
+_show_cpi_info(CLPI_CPI *cpi, int level)
+{
+    CLPI_EP_MAP_ENTRY *entry;
+    CLPI_EP_COARSE *coarse;
+    CLPI_EP_FINE *fine;
+    int ii, jj, kk;
+
+    indent_printf(level, "CPI");
+    indent_printf(level+1, "Number Stream PID: %d", cpi->num_stream_pid);
+    for (ii = 0; ii < cpi->num_stream_pid; ii++) {
+        entry = &cpi->entry[ii];
+        indent_printf(level+1, "Stream: %d", ii);
+        indent_printf(level+2, "PID: %04x", entry->pid);
+        indent_printf(level+2, "EP Stream Type: %d", entry->ep_stream_type);
+        indent_printf(level+2, "Number EP Coarse: %d", entry->num_ep_coarse);
+        indent_printf(level+2, "Number EP Fine: %d", entry->num_ep_fine);
+        indent_printf(level+2, "EP Map Start: %d", 
+                        entry->ep_map_stream_start_addr);
+        for (jj = 0; jj < entry->num_ep_coarse; jj++) {
+            coarse = &entry->coarse[jj];
+            indent_printf(level+2, "Coarse: %d", jj);
+            indent_printf(level+3, "Ref EP Fine: %d", coarse->ref_ep_fine_id);
+            indent_printf(level+3, "PTS EP: %d", coarse->pts_ep);
+            indent_printf(level+3, "SPN EP: %d", coarse->spn_ep);
+        }
+        for (jj = 0; jj < entry->num_ep_fine; jj++) {
+            fine = &entry->fine[jj];
+            indent_printf(level+2, "Fine: %d", jj);
+            indent_printf(level+3, "Angle Change Point: %s", 
+                fine->is_angle_change_point ? "True":"False");
+            indent_printf(level+3, "I End Offset: %d", 
+                fine->i_end_position_offset);
+            indent_printf(level+3, "PTS EP: %d", fine->pts_ep);
+            indent_printf(level+3, "SPN EP: %d", fine->spn_ep);
+        }
+        if (verbose) {
+            uint64_t pts;
+            uint32_t spn;
+
+            indent_printf(level+2, "PTS - SPN Map");
+            for (jj = 0; jj < entry->num_ep_coarse; jj++) {
+                int start, end;
+
+                indent_printf(level+3, "Coarse: %d", jj);
+                coarse = &entry->coarse[jj];
+                start = coarse->ref_ep_fine_id;
+                if (jj < entry->num_ep_coarse - 1) {
+                    end = entry->coarse[jj+1].ref_ep_fine_id;
+                } else {
+                    end = entry->num_ep_fine;
+                }
+                for (kk = start; kk < end; kk++) {
+                    fine = &entry->fine[kk];
+                    pts = ((uint64_t) (coarse->pts_ep & ~0x01) << 19) +
+                            ((uint64_t)fine->pts_ep << 9);
+                    spn = (coarse->spn_ep & ~0x1FFFF) + fine->spn_ep;
+                    indent_printf(level+4, "PTS %8"PRIu64"/%8"PRIu64" -- SPN %u",
+                        pts, pts >> 1, spn);
+                }
+            }
+        }
+    }
+}
+
+
+static void
+_usage(char *cmd)
+{
+    fprintf(stderr, 
+"Usage: %s -vcspi <clpi file> [<clpi file> ...]\n"
+"With no options, produces no output (not very useful)\n"
+"Options:\n"
+"    v - Verbose output.\n"
+"    c - Shows the Clip Info structure\n"
+"    s - Shows the Sequence Info structure\n"
+"    p - Shows the Program Info structure\n"
+"    i - Shows the CPI. PTS to SPN map\n"
+"    e - Shows Extent Start Table\n"
+, cmd);
+
+    exit(EXIT_FAILURE);
+}
+
+#define OPTS "vcspie"
+
+int
+main(int argc, char *argv[])
+{
+    CLPI_CL *cl;
+    int opt;
+    int opt_clip_info = 0, opt_seq_info = 0, opt_prog_info = 0;
+    int opt_cpi_info = 0, opt_extent_start = 0;
+    int ii;
+
+    do {
+        opt = getopt(argc, argv, OPTS);
+        switch (opt) {
+            case -1: break;
+
+            case 'v':
+                verbose = 1;
+                break;
+
+            case 's':
+                opt_seq_info = 1;
+                break;
+
+            case 'i':
+                opt_cpi_info = 1;
+                break;
+
+            case 'c':
+                opt_clip_info = 1;
+                break;
+
+            case 'p':
+                opt_prog_info = 1;
+                break;
+
+            case 'e':
+                opt_extent_start = 1;
+                break;
+
+            default:
+                _usage(argv[0]);
+                break;
+        }
+    } while (opt != -1);
+
+    if (optind >= argc) {
+        _usage(argv[0]);
+    }
+
+    for (ii = optind; ii < argc; ii++) {
+        cl = bd_read_clpi(argv[ii]);
+        if (cl == NULL) {
+            fprintf(stderr, "Parsing %s failed\n", argv[ii]);
+            continue;
+        }
+        if (opt_clip_info) {
+            // Show clip info
+            _show_clip_info(cl, 1);
+        }
+        if (opt_seq_info) {
+            // Show sequence info
+            _show_seq_info(&cl->sequence, 1);
+        }
+        if (opt_prog_info) {
+            // Show program info
+            _show_prog_info(&cl->program, 1);
+        }
+        if (opt_cpi_info) {
+            // Show cpi
+            _show_cpi_info(&cl->cpi, 1);
+        }
+
+        if (opt_prog_info) {
+            if (cl->program_ss.num_prog) {
+                printf("\n");
+                indent_printf(1, "Extension: Program Info SS");
+                _show_prog_info(&cl->program_ss, 1);
+            }
+        }
+        if (opt_cpi_info) {
+            if (cl->program_ss.num_prog) {
+                printf("\n");
+                indent_printf(1, "Extension: CPI SS");
+                _show_cpi_info(&cl->cpi_ss, 1);
+            }
+        }
+        if (opt_extent_start) {
+            // Show extent start point
+            if (cl->extent_start.num_point > 0) {
+                _show_extent_start(&cl->extent_start, 1);
+            }
+        }
+
+        bd_free_clpi(cl);
+    }
+    return 0;
+}
+
diff --git a/src/devtools/hdmv_test.c b/src/devtools/hdmv_test.c
new file mode 100644
index 0000000..585ed70
--- /dev/null
+++ b/src/devtools/hdmv_test.c
@@ -0,0 +1,257 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2010  hpi1
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <inttypes.h>
+
+#include "util/log_control.h"
+#include "libbluray/bluray.h"
+
+static void _print_event(BD_EVENT *ev)
+{
+    switch (ev->event) {
+        case BD_EVENT_NONE:
+            break;
+        case BD_EVENT_ERROR:
+            printf("EVENT_ERROR:\t%d\n", ev->param);
+            break;
+        case BD_EVENT_READ_ERROR:
+            printf("EVENT_READ_ERROR:\t%d\n", ev->param);
+            break;
+        case BD_EVENT_ENCRYPTED:
+            printf("EVENT_ENCRYPTED:\t%d\n", ev->param);
+            break;
+
+        /* current playback position */
+
+        case BD_EVENT_ANGLE:
+            printf("EVENT_ANGLE:\t%d\n", ev->param);
+            break;
+        case BD_EVENT_TITLE:
+            printf("EVENT_TITLE:\t%d\n", ev->param);
+            break;
+        case BD_EVENT_PLAYLIST:
+            printf("EVENT_PLAYLIST:\t%d\n", ev->param);
+            break;
+        case BD_EVENT_PLAYITEM:
+            printf("EVENT_PLAYITEM:\t%d\n", ev->param);
+            break;
+        case BD_EVENT_CHAPTER:
+            printf("EVENT_CHAPTER:\t%d\n", ev->param);
+            break;
+
+        /* */
+
+        case BD_EVENT_STILL:
+            printf("EVENT_STILL:\t%d\n", ev->param);
+            break;
+
+        case BD_EVENT_SEEK:
+            printf("EVENT_SEEK:\t%d\n", ev->param);
+            break;
+
+        case BD_EVENT_STILL_TIME:
+            if (ev->param) {
+                printf("EVENT_STILL_TIME:\t%d\n", ev->param);
+            } else {
+                printf("EVENT_STILL_TIME:\tinfinite\n");
+            }
+            break;
+
+        /* stream selection */
+
+        case BD_EVENT_AUDIO_STREAM:
+            printf("EVENT_AUDIO_STREAM:\t%d\n", ev->param);
+            break;
+        case BD_EVENT_IG_STREAM:
+            printf("EVENT_IG_STREAM:\t%d\n", ev->param);
+            break;
+        case BD_EVENT_PG_TEXTST_STREAM:
+            printf("EVENT_PG_TEXTST_STREAM:\t%d\n", ev->param);
+            break;
+        case BD_EVENT_SECONDARY_AUDIO_STREAM:
+            printf("EVENT_SECONDARY_AUDIO_STREAM:\t%d\n", ev->param);
+            break;
+        case BD_EVENT_SECONDARY_VIDEO_STREAM:
+            printf("EVENT_SECONDARY_VIDEO_STREAM:\t%d\n", ev->param);
+            break;
+
+        case BD_EVENT_PG_TEXTST:
+            printf("EVENT_PG_TEXTST:\t%s\n", ev->param ? "enable" : "disable");
+            break;
+        case BD_EVENT_SECONDARY_AUDIO:
+            printf("EVENT_SECONDARY_AUDIO:\t%s\n", ev->param ? "enable" : "disable");
+            break;
+        case BD_EVENT_SECONDARY_VIDEO:
+            printf("EVENT_SECONDARY_VIDEO:\t%s\n", ev->param ? "enable" : "disable");
+            break;
+        case BD_EVENT_SECONDARY_VIDEO_SIZE:
+            printf("EVENT_SECONDARY_VIDEO_SIZE:\t%s\n", ev->param==0 ? "PIP" : "fullscreen");
+            break;
+
+        default:
+            printf("UNKNOWN EVENT %d:\t%d\n", ev->event, ev->param);
+            break;
+      }
+
+      fflush(stdout);
+}
+
+static void _read_to_eof(BLURAY *bd)
+{
+    BD_EVENT ev;
+    int      bytes;
+    uint64_t total = 0;
+    uint8_t  buf[6144];
+
+    bd_seek(bd, bd_get_title_size(bd) - 6144);
+
+    do {
+        bytes = bd_read_ext(bd, buf, 6144, &ev);
+        total += bytes < 0 ? 0 : bytes;
+        _print_event(&ev);
+    } while (bytes > 0);
+
+    printf("_read_to_eof(): read %"PRIu64" bytes\n", total);
+}
+
+static void _print_events(BLURAY *bd)
+{
+    BD_EVENT ev;
+
+    do {
+        bd_read_ext(bd, NULL, 0, &ev);
+        _print_event(&ev);
+    } while (ev.event != BD_EVENT_NONE && ev.event != BD_EVENT_ERROR);
+}
+
+static void _play_pl(BLURAY *bd)
+{
+    printf("Playing playlist\n");
+
+    fflush(stdout);
+    _read_to_eof(bd);
+
+    printf("Playing playlist done\n\n");
+
+    _print_events(bd);
+
+    printf("\n");
+}
+
+int main(int argc, char *argv[])
+{
+    int title = -1;
+    int verbose = 0;
+    int args = 0;
+
+    /*
+     * parse arguments
+     */
+
+    if (argc < 2) {
+        printf("\nUsage:\n   %s [-v] [-t <title>] <media_path> [<keyfile_path>]\n\n", argv[0]);
+        return -1;
+    }
+
+    if (!strcmp(argv[1+args], "-v")) {
+        verbose = 1;
+        args++;
+    }
+
+    if (!strcmp(argv[1+args], "-t")) {
+        args++;
+        title = atoi(argv[1+args]);
+        args++;
+        printf("Requested title %d\n", title);
+    }
+
+    if (verbose) {
+        printf("Enabling verbose debug\n");
+        bd_set_debug_mask(bd_get_debug_mask() | DBG_HDMV | DBG_BLURAY);
+    }
+
+    printf("\n");
+
+    /*
+     * open and setup
+     */
+
+    BLURAY  *bd = bd_open(argv[1+args], argv[2+args]);
+
+    if (!bd) {
+        printf("bd_open(\'%s\') failed\n", argv[1]);
+        return -1;
+    }
+
+    bd_set_player_setting    (bd, BLURAY_PLAYER_SETTING_PARENTAL,     99);
+    bd_set_player_setting_str(bd, BLURAY_PLAYER_SETTING_AUDIO_LANG,   "eng");
+    bd_set_player_setting_str(bd, BLURAY_PLAYER_SETTING_PG_LANG,      "eng");
+    bd_set_player_setting_str(bd, BLURAY_PLAYER_SETTING_MENU_LANG,    "eng");
+    bd_set_player_setting_str(bd, BLURAY_PLAYER_SETTING_COUNTRY_CODE, NULL);
+
+    /*
+     * play
+     */
+
+    printf("Running first play movie object\n");
+
+    fflush(stdout);
+    bd_play(bd);
+
+    _print_events(bd);
+
+    printf("\n");
+
+    /*
+     * play title
+     */
+
+    if (title >= 0) {
+        printf("Playing title %d\n", title);
+
+        fflush(stdout);
+        bd_play_title(bd, title);
+
+        _print_events(bd);
+
+        printf("\n");
+    }
+
+    /*
+     * play playlist
+     */
+
+    _play_pl(bd);
+
+    _play_pl(bd);
+
+    _play_pl(bd);
+
+    /*
+     * clean up
+     */
+
+    bd_close(bd);
+
+    return 0;
+}
+
diff --git a/src/devtools/mobj_dump.c b/src/devtools/mobj_dump.c
new file mode 100644
index 0000000..3eaf9f4
--- /dev/null
+++ b/src/devtools/mobj_dump.c
@@ -0,0 +1,83 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2010  hpi1
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+#include "libbluray/bluray.h"
+
+#include "libbluray/hdmv/mobj_data.h"
+#include "libbluray/hdmv/mobj_print.h"
+
+#include <stdio.h>
+#include <string.h>
+
+static void _mobj_print(MOBJ_OBJECTS *objects, int disasm)
+{
+    int o, c;
+
+    printf("Number of objects: %d\n", objects->num_objects);
+
+    for (o = 0; o < objects->num_objects; o++) {
+
+        printf("Object %d:\n"
+               "  number of commands:    %d\n"
+               "  resume intention flag: %d\n"
+               "  menu call mask:        %d\n"
+               "  title search mask:     %d\n",
+               o, objects->objects[o].num_cmds,
+               objects->objects[o].resume_intention_flag,
+               objects->objects[o].menu_call_mask,
+               objects->objects[o].title_search_mask);
+
+            if (disasm) {
+                printf("  program:\n");
+                for (c = 0; c < objects->objects[o].num_cmds; c++) {
+                    char buf[256];
+                    mobj_sprint_cmd(buf, &objects->objects[o].cmds[c]);
+                    printf("    %04d: %s\n", c, buf);
+                }
+            }
+    }
+}
+
+int main(int argc, const char *argv[])
+{
+    int           disasm = 0;
+    MOBJ_OBJECTS *mobj = NULL;
+
+    if (argc < 2) {
+        fprintf(stderr,
+                "usage: %s [-d] <file>\n"
+                "Options:\n"
+                "    d         disassemble object code\n",
+                argv[0]);
+        return 1;
+    }
+    if (argc > 2) {
+        disasm = !strcmp(argv[1], "-d");
+    }
+
+    mobj = bd_read_mobj(argv[argc-1]);
+
+    if (mobj) {
+        _mobj_print(mobj, disasm);
+
+        bd_free_mobj(mobj);
+    }
+
+    return 0;
+}
diff --git a/src/devtools/mpls_dump.c b/src/devtools/mpls_dump.c
new file mode 100644
index 0000000..405b6a1
--- /dev/null
+++ b/src/devtools/mpls_dump.c
@@ -0,0 +1,799 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2009-2010  John Stebbins
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+#include <sys/stat.h>
+#include <dirent.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <libgen.h>
+
+#include "libbluray/bdnav/mpls_parse.h"
+#include "libbluray/bluray.h"
+
+#include "util.h"
+
+#ifdef _WIN32
+# define DIR_SEP "\\"
+# define PLAYLIST_DIR "\\BDMV\\PLAYLIST"
+#else
+# define DIR_SEP "/"
+# define PLAYLIST_DIR "/BDMV/PLAYLIST"
+#endif
+
+
+static int verbose;
+
+typedef struct {
+    int value;
+    const char *str;
+} VALUE_MAP;
+
+const VALUE_MAP codec_map[] = {
+    {0x01, "MPEG-1 Video"},
+    {0x02, "MPEG-2 Video"},
+    {0x03, "MPEG-1 Audio"},
+    {0x04, "MPEG-2 Audio"},
+    {0x80, "LPCM"},
+    {0x81, "AC-3"},
+    {0x82, "DTS"},
+    {0x83, "TrueHD"},
+    {0x84, "AC-3 Plus"},
+    {0x85, "DTS-HD"},
+    {0x86, "DTS-HD Master"},
+    {0xa1, "AC-3 Plus for secondary audio"},
+    {0xa2, "DTS-HD for secondary audio"},
+    {0xea, "VC-1"},
+    {0x1b, "H.264"},
+    {0x90, "Presentation Graphics"},
+    {0x91, "Interactive Graphics"},
+    {0x92, "Text Subtitle"},
+    {0, NULL}
+};
+
+const VALUE_MAP video_format_map[] = {
+    {0, "Reserved"},
+    {1, "480i"},
+    {2, "576i"},
+    {3, "480p"},
+    {4, "1080i"},
+    {5, "720p"},
+    {6, "1080p"},
+    {7, "576p"},
+    {0, NULL}
+};
+
+const VALUE_MAP video_rate_map[] = {
+    {0, "Reserved1"},
+    {1, "23.976"},
+    {2, "24"},
+    {3, "25"},
+    {4, "29.97"},
+    {5, "Reserved2"},
+    {6, "50"},
+    {7, "59.94"},
+    {0, NULL}
+};
+
+const VALUE_MAP audio_format_map[] = {
+    {0, "Reserved1"},
+    {1, "Mono"},
+    {2, "Reserved2"},
+    {3, "Stereo"},
+    {4, "Reserved3"},
+    {5, "Reserved4"},
+    {6, "Multi Channel"},
+    {12, "Combo"},
+    {0, NULL}
+};
+
+const VALUE_MAP audio_rate_map[] = {
+    {0, "Reserved1"},
+    {1, "48 Khz"},
+    {2, "Reserved2"},
+    {3, "Reserved3"},
+    {4, "96 Khz"},
+    {5, "192 Khz"},
+    {12, "48/192 Khz"},
+    {14, "48/96 Khz"},
+    {0, NULL}
+};
+
+const VALUE_MAP subpath_type_map[] = {
+  {2, "Primary audio of the Browsable slideshow"},
+  {3, "Interactive Graphics presentation menu"},
+  {4, "Text Subtitle"},
+  {5, "Out-of-mux Synchronous elementary streams"},
+  {6, "Out-of-mux Asynchronous Picture-in-Picture presentation"},
+  {7, "In-mux Synchronous Picture-in-Picture presentation"},
+  {8, "SS Video"},
+  {0,NULL}
+};
+
+const VALUE_MAP playback_type_map[] = {
+  {1, "Sequential"},
+  {2, "Random"},
+  {3, "Shuffle"},
+  {0, NULL}
+};
+
+const VALUE_MAP connection_type_map[] = {
+  {1, "Non-seamless"},
+  {5, "Seamless"},
+  {6, "Seamless"},
+  {0, NULL}
+};
+
+static const char*
+_lookup_str(const VALUE_MAP *map, int val)
+{
+    int ii;
+
+    for (ii = 0; map[ii].str; ii++) {
+        if (val == map[ii].value) {
+            return map[ii].str;
+        }
+    }
+    return "?";
+}
+
+static char *
+_mk_path(const char *base, const char *sub)
+{
+    size_t n1 = strlen(base);
+    size_t n2 = strlen(sub);
+    char *result = (char*)malloc(n1 + n2 + strlen(DIR_SEP) + 1);
+    strcpy(result, base);
+    strcat(result, DIR_SEP);
+    strcat(result, sub);
+
+    return result;
+}
+
+static void
+_show_stream(MPLS_STREAM *ss, int level)
+{
+    indent_printf(level, "Codec (%04x): %s", ss->coding_type,
+                    _lookup_str(codec_map, ss->coding_type));
+    switch (ss->stream_type) {
+        case 1:
+            indent_printf(level, "PID: %04x", ss->pid);
+            break;
+
+        case 2:
+        case 4:
+            indent_printf(level, "SubPath Id: %02x", ss->subpath_id);
+            indent_printf(level, "SubClip Id: %02x", ss->subclip_id);
+            indent_printf(level, "PID: %04x", ss->pid);
+            break;
+
+        case 3:
+            indent_printf(level, "SubPath Id: %02x", ss->subpath_id);
+            indent_printf(level, "PID: %04x", ss->pid);
+            break;
+
+        default:
+            fprintf(stderr, "unrecognized stream type %02x\n", ss->stream_type);
+            break;
+    };
+
+    switch (ss->coding_type) {
+        case 0x01:
+        case 0x02:
+        case 0xea:
+        case 0x1b:
+            indent_printf(level, "Format %02x: %s", ss->format,
+                        _lookup_str(video_format_map, ss->format));
+            indent_printf(level, "Rate %02x: %s", ss->rate,
+                        _lookup_str(video_rate_map, ss->rate));
+            break;
+
+        case 0x03:
+        case 0x04:
+        case 0x80:
+        case 0x81:
+        case 0x82:
+        case 0x83:
+        case 0x84:
+        case 0x85:
+        case 0x86:
+        case 0xa1:
+        case 0xa2:
+            indent_printf(level, "Format %02x: %s", ss->format,
+                        _lookup_str(audio_format_map, ss->format));
+            indent_printf(level, "Rate %02x: %s", ss->rate,
+                        _lookup_str(audio_rate_map, ss->rate));
+            indent_printf(level, "Language: %s", ss->lang);
+            break;
+
+        case 0x90:
+        case 0x91:
+            indent_printf(level, "Language: %s", ss->lang);
+            break;
+
+        case 0x92:
+            indent_printf(level, "Char Code: %02x", ss->char_code);
+            indent_printf(level, "Language: %s", ss->lang);
+            break;
+
+        default:
+            fprintf(stderr, "unrecognized coding type %02x\n", ss->coding_type);
+            break;
+    };
+}
+
+static void
+_show_details(MPLS_PL *pl, int level)
+{
+    int ii, jj, kk;
+
+    for (ii = 0; ii < pl->list_count; ii++) {
+        MPLS_PI *pi;
+
+        pi = &pl->play_item[ii];
+        indent_printf(level, "Clip Id %s", pi->clip[0].clip_id);
+        indent_printf(level+1, "Stc Id: %02x", pi->clip[0].stc_id);
+        indent_printf(level+1, "Connection Condition: %s (%02x)",
+                      _lookup_str(connection_type_map, pi->connection_condition),
+                      pi->connection_condition);
+        indent_printf(level+1, "In-Time: %d", pi->in_time);
+        indent_printf(level+1, "Out-Time: %d", pi->out_time);
+        if (pi->still_mode == 1) {
+            indent_printf(level+1, "Still time: %ds\n", pi->still_time);
+        }
+        if (pi->still_mode == 2) {
+            indent_printf(level+1, "Still time: infinite\n");
+        }
+        if (pi->angle_count > 1) {
+            for (jj = 1; jj < pi->angle_count; jj++) {
+                indent_printf(level+1, "Angle %d:", jj);
+                indent_printf(level+2, "Clip Id %s", pi->clip[jj].clip_id);
+                indent_printf(level+2, "Stc Id: %02x", pi->clip[jj].stc_id);
+            }
+        }
+        for (jj = 0; jj < pi->stn.num_video; jj++) {
+            indent_printf(level+1, "Video Stream %d:", jj);
+            _show_stream(&pi->stn.video[jj], level + 2);
+        }
+        for (jj = 0; jj < pi->stn.num_audio; jj++) {
+            indent_printf(level+1, "Audio Stream %d:", jj);
+            _show_stream(&pi->stn.audio[jj], level + 2);
+        }
+        for (jj = 0; jj < pi->stn.num_ig; jj++) {
+            indent_printf(level+1, "Interactive Graphics Stream %d:", jj);
+            _show_stream(&pi->stn.ig[jj], level + 2);
+        }
+        for (jj = 0; jj < (pi->stn.num_pg + pi->stn.num_pip_pg); jj++) {
+            if (jj < pi->stn.num_pg) {
+               indent_printf(level+1, "Presentation Graphics Stream %d:", jj);
+            } else {
+                indent_printf(level+1, "PIP Presentation Graphics Stream %d:", jj);
+            }
+            _show_stream(&pi->stn.pg[jj], level + 2);
+        }
+        for (jj = 0; jj < pi->stn.num_secondary_video; jj++) {
+            indent_printf(level+1, "Secondary Video Stream %d:", jj);
+            _show_stream(&pi->stn.secondary_video[jj], level + 2);
+            for (kk = 0; kk < pi->stn.secondary_video[jj].sv_num_secondary_audio_ref; kk++) {
+                indent_printf(level+2, "Secondary Audio Ref %d: %d", kk,pi->stn.secondary_video[jj].sv_secondary_audio_ref[kk]);
+            }
+            for (kk = 0; kk < pi->stn.secondary_video[jj].sv_num_pip_pg_ref; kk++) {
+                indent_printf(level+2, "PIP Presentation Graphic Ref %d: %d", kk,pi->stn.secondary_video[jj].sv_pip_pg_ref[kk]);
+            }
+        }
+        for (jj = 0; jj < pi->stn.num_secondary_audio; jj++) {
+            indent_printf(level+1, "Secondary Audio Stream %d:", jj);
+            _show_stream(&pi->stn.secondary_audio[jj], level + 2);
+            for (kk = 0; kk < pi->stn.secondary_audio[jj].sa_num_primary_audio_ref; kk++) {
+                indent_printf(level+2, "Primary Audio Ref %d: %d", kk,pi->stn.secondary_audio[jj].sa_primary_audio_ref[kk]);
+            }
+        }
+        printf("\n");
+    }
+}
+
+static void
+_show_ai(MPLS_PL *pl, int level)
+{
+    indent_printf(level, "Playback type: %s (%d)",
+                  _lookup_str(playback_type_map, pl->app_info.playback_type),
+                  pl->app_info.playback_type);
+    if (pl->app_info.playback_type == 2 || pl->app_info.playback_type == 3) {
+        indent_printf(level+1, "Playback count: %d", pl->app_info.playback_count);
+    }
+}
+
+static void
+_show_marks(MPLS_PL *pl, int level)
+{
+    int ii;
+
+    indent_printf(level, "PlayMark Count %d", pl->mark_count);
+    for (ii = 0; ii < pl->mark_count; ii++) {
+        MPLS_PI *pi;
+        MPLS_PLM *plm;
+        int min;
+        double sec;
+
+        plm = &pl->play_mark[ii];
+        indent_printf(level, "PlayMark %d", ii);
+        indent_printf(level+1, "Type: %02x", plm->mark_type);
+        if (plm->play_item_ref < pl->list_count) {
+            pi = &pl->play_item[plm->play_item_ref];
+            indent_printf(level+1, "PlayItem: %s", pi->clip[0].clip_id);
+        } else {
+            indent_printf(level+1, "PlayItem: Invalid reference");
+        }
+        indent_printf(level+1, "Time (ticks): %u", plm->time);
+        min = plm->duration / (45000*60);
+        sec = (double)(plm->duration - min * 45000 * 60) / 45000;
+        indent_printf(level+1, "Duration (mm:ss.ms, ticks): %d:%.2f, %u",
+                      min, sec, plm->duration);
+        printf("\n");
+    }
+}
+
+static void
+_show_clip_list(MPLS_PL *pl, int level)
+{
+    int ii, jj;
+
+    for (ii = 0; ii < pl->list_count; ii++) {
+        MPLS_PI *pi;
+
+        pi = &pl->play_item[ii];
+        if (verbose) {
+            uint32_t duration;
+
+            duration = pi->out_time - pi->in_time;
+            indent_printf(level, "%s.m2ts -- Duration: %3d:%02d", 
+                        pi->clip[0].clip_id,
+                        duration / (45000 * 60), (duration / 45000) % 60);
+        } else {
+            indent_printf(level, "%s.m2ts", pi->clip[0].clip_id);
+        }
+        if (pi->angle_count > 1) {
+            for (jj = 1; jj < pi->angle_count; jj++) {
+                indent_printf(level+1, "Angle %d: %s.m2ts", jj+1, pi->clip[jj].clip_id);
+            }
+        }
+    }
+    printf("\n");
+}
+
+static void
+_show_sub_path(MPLS_SUB *sub, int level)
+{
+    int ii;
+
+    indent_printf(level+1, "Type: %d (%s)", sub->type, _lookup_str(subpath_type_map, sub->type));
+    indent_printf(level+1, "Repeat: %d", sub->is_repeat);
+    indent_printf(level+1, "Sub playitem count: %d", sub->sub_playitem_count);
+
+    for (ii = 0; ii < sub->sub_playitem_count; ii++) {
+        MPLS_SUB_PI *pi;
+
+        pi = &sub->sub_play_item[ii];
+
+        if (verbose) {
+            indent_printf(level+1, "Sub playitem %d", ii);
+            indent_printf(level+2, "Clip Id %s", pi->clip[0].clip_id);
+            indent_printf(level+2, "Multi clip: %d", pi->is_multi_clip);
+            indent_printf(level+2, "Clip count: %d", pi->clip_count);
+            indent_printf(level+2, "Connection Condition: %s (%02x)",
+                          _lookup_str(connection_type_map, pi->connection_condition),
+                          pi->connection_condition);
+            indent_printf(level+2, "In-Time: %d", pi->in_time);
+            indent_printf(level+2, "Out-Time: %d", pi->out_time);
+            indent_printf(level+2, "Sync playitem Id: %d", pi->sync_play_item_id);
+            indent_printf(level+2, "Sync PTS: %d", pi->sync_pts);
+        } else {
+            indent_printf(level+1, "%s.m2ts", pi->clip[0].clip_id);
+        }
+    }
+}
+
+static void
+_show_pip_metadata_block(MPLS_PIP_METADATA *block, int level)
+{
+    int ii;
+
+    indent_printf(level, "Clip ref: %d", block->clip_ref);
+    indent_printf(level, "Secondary video ref: %d", block->secondary_video_ref);
+    indent_printf(level, "Timeline type: %d", block->timeline_type);
+    indent_printf(level, "Luma key flag: %d", block->luma_key_flag);
+    if (block->luma_key_flag) {
+        indent_printf(level, "Upper limit luma key: %d", block->upper_limit_luma_key);
+    }
+    indent_printf(level, "Trick play flag: %d", block->trick_play_flag);
+
+    for (ii = 0; ii < block->data_count; ii++) {
+        indent_printf(level, "data block %d:", ii);
+        indent_printf(level+1, "Timestamp: %d", block->data[ii].time);
+        indent_printf(level+1, "Horizontal position %d", block->data[ii].xpos);
+        indent_printf(level+1, "Vertical position: %d", block->data[ii].ypos);
+        indent_printf(level+1, "Scaling factor: %d", block->data[ii].scale_factor);
+    }
+}
+
+static void
+_show_pip_metadata(MPLS_PL *pl, int level)
+{
+    int ii;
+
+    for (ii = 0; ii < pl->ext_pip_data_count; ii++) {
+        MPLS_PIP_METADATA *data;
+
+        data = &pl->ext_pip_data[ii];
+
+        indent_printf(level, "PiP metadata block %d:", ii);
+        _show_pip_metadata_block(data, level+1);
+    }
+}
+
+static void
+_show_sub_paths(MPLS_PL *pl, int level)
+{
+    int ss;
+
+    for (ss = 0; ss < pl->sub_count; ss++) {
+        MPLS_SUB *sub;
+
+        sub = &pl->sub_path[ss];
+
+        indent_printf(level, "Sub Path %d:", ss);
+        _show_sub_path(sub, level+1);
+    }
+}
+
+static void
+_show_sub_paths_ss(MPLS_PL *pl, int level)
+{
+    int ss;
+
+    for (ss = 0; ss < pl->ext_sub_count; ss++) {
+        MPLS_SUB *sub;
+
+        sub = &pl->ext_sub_path[ss];
+
+        indent_printf(level, "Extension Sub Path %d:", ss);
+        _show_sub_path(sub, level+1);
+    }
+}
+
+static uint32_t
+_pl_duration(MPLS_PL *pl)
+{
+    int ii;
+    uint32_t duration = 0;
+    MPLS_PI *pi;
+
+    for (ii = 0; ii < pl->list_count; ii++) {
+        pi = &pl->play_item[ii];
+        duration += pi->out_time - pi->in_time;
+    }
+    return duration;
+}
+
+static int
+_filter_dup(MPLS_PL *pl_list[], int count, MPLS_PL *pl)
+{
+    int ii, jj;
+
+    for (ii = 0; ii < count; ii++) {
+        if (pl->list_count != pl_list[ii]->list_count ||
+            _pl_duration(pl) != _pl_duration(pl_list[ii])) {
+            continue;
+        }
+        for (jj = 0; jj < pl->list_count; jj++) {
+            MPLS_PI *pi1, *pi2;
+
+            pi1 = &pl->play_item[jj];
+            pi2 = &pl_list[ii]->play_item[jj];
+
+            if (memcmp(pi1->clip[0].clip_id, pi2->clip[0].clip_id, 5) != 0 ||
+                pi1->in_time != pi2->in_time ||
+                pi1->out_time != pi2->out_time) {
+                break;
+            }
+        }
+        if (jj != pl->list_count) {
+            continue;
+        }
+        return 0;
+    }
+    return 1;
+}
+
+static int
+_find_repeats(MPLS_PL *pl, const char *m2ts)
+{
+    int ii, count = 0;
+
+    for (ii = 0; ii < pl->list_count; ii++) {
+        MPLS_PI *pi;
+
+        pi = &pl->play_item[ii];
+        // Ignore titles with repeated segments
+        if (strcmp(pi->clip[0].clip_id, m2ts) == 0) {
+            count++;
+        }
+    }
+    return count;
+}
+
+static int
+_filter_short(MPLS_PL *pl, unsigned int seconds)
+{
+    // Ignore short playlists
+    if (_pl_duration(pl) / 45000 <= seconds) {
+        return 0;
+    }
+    return 1;
+}
+
+static int
+_filter_repeats(MPLS_PL *pl, int repeats)
+{
+    int ii;
+
+    for (ii = 0; ii < pl->list_count; ii++) {
+        MPLS_PI *pi;
+
+        pi = &pl->play_item[ii];
+        // Ignore titles with repeated segments
+        if (_find_repeats(pl, pi->clip[0].clip_id) > repeats) {
+            return 0;
+        }
+    }
+    return 1;
+}
+
+static int clip_list = 0, playlist_info = 0, chapter_marks = 0, sub_paths = 0, pip_metadata = 0;
+static int repeats = 0, seconds = 0, dups = 0;
+
+static MPLS_PL*
+_process_file(char *name, MPLS_PL *pl_list[], int pl_count)
+{
+    MPLS_PL *pl;
+
+    pl = bd_read_mpls(name);
+    if (pl == NULL) {
+        fprintf(stderr, "Parse failed: %s\n", name);
+        return NULL;
+    }
+    if (seconds) {
+        if (!_filter_short(pl, seconds)) {
+            bd_free_mpls(pl);
+            return NULL;
+        }
+    }
+    if (repeats) {
+        if (!_filter_repeats(pl, repeats)) {
+            bd_free_mpls(pl);
+            return NULL;
+        }
+    }
+    if (dups) {
+        if (!_filter_dup(pl_list, pl_count, pl)) {
+            bd_free_mpls(pl);
+            return NULL;
+        }
+    }
+    if (verbose) {
+        indent_printf(0, 
+                    "%s -- Num Clips: %3d , Duration: minutes %4u:%02u",
+                    basename(name),
+                    pl->list_count,
+                    _pl_duration(pl) / (45000 * 60),
+                    (_pl_duration(pl) / 45000) % 60);
+        _show_ai(pl, 1);
+    } else {
+        indent_printf(0, "%s -- Duration: minutes %4u:%02u",
+                    basename(name),
+                    _pl_duration(pl) / (45000 * 60),
+                    (_pl_duration(pl) / 45000) % 60);
+    }
+    if (playlist_info) {
+        _show_details(pl, 1);
+    }
+    if (chapter_marks) {
+        _show_marks(pl, 1);
+    }
+    if (pip_metadata) {
+        _show_pip_metadata(pl, 1);
+    }
+    if (clip_list) {
+        _show_clip_list(pl, 1);
+    }
+    if (sub_paths) {
+        _show_sub_paths(pl, 1);
+        _show_sub_paths_ss(pl, 1);
+    }
+    return pl;
+}
+
+static void
+_usage(char *cmd)
+{
+    fprintf(stderr, 
+"Usage: %s -vli <mpls file> [<mpls file> ...]\n"
+"With no options, produces a list of the playlist(s) with durations\n"
+"Options:\n"
+"    v             - Verbose output.\n"
+"    l             - Produces a list of the m2ts clips\n"
+"    i             - Dumps detailed information about each clip\n"
+"    c             - Show chapter marks\n"
+"    p             - Show sub paths\n"
+"    P             - Show picture-in-picture metadata\n"
+"    r <N>         - Filter out titles that have >N repeating clips\n"
+"    d             - Filter out duplicate titles\n"
+"    s <seconds>   - Filter out short titles\n"
+"    f             - Filter combination -r2 -d -s900\n"
+, cmd);
+
+    exit(EXIT_FAILURE);
+}
+
+#define OPTS "vlicpPfr:ds:"
+
+static int
+_qsort_str_cmp(const void *a, const void *b)
+{
+    const char *stra = *(char * const *)a;
+    const char *strb = *(char * const *)b;
+
+    return strcmp(stra, strb);
+}
+
+int
+main(int argc, char *argv[])
+{
+    MPLS_PL *pl;
+    int opt;
+    int ii, pl_ii;
+    MPLS_PL *pl_list[1000];
+    struct stat st;
+    char *path = NULL;
+    DIR *dir = NULL;
+
+    do {
+        opt = getopt(argc, argv, OPTS);
+        switch (opt) {
+            case -1: 
+                break;
+
+            case 'v':
+                verbose = 1;
+                break;
+
+            case 'l':
+                clip_list = 1;
+                break;
+
+            case 'i':
+                playlist_info = 1;
+                break;
+
+            case 'c':
+                chapter_marks = 1;
+                break;
+
+            case 'p':
+                sub_paths = 1;
+                break;
+
+            case 'P':
+                pip_metadata = 1;
+                break;
+
+            case 'd':
+                dups = 1;
+                break;
+
+            case 'r':
+                repeats = atoi(optarg);
+                break;
+
+            case 'f':
+                repeats = 2;
+                dups = 1;
+                seconds = 900;
+                break;
+
+            case 's':
+                seconds = atoi(optarg);
+                break;
+
+            default:
+                _usage(argv[0]);
+                break;
+        }
+    } while (opt != -1);
+
+    if (optind >= argc) {
+        _usage(argv[0]);
+    }
+
+    for (pl_ii = 0, ii = optind; pl_ii < 1000 && ii < argc; ii++) {
+
+        if (stat(argv[ii], &st)) {
+            continue;
+        }
+        dir = NULL;
+        if (S_ISDIR(st.st_mode)) {
+
+            printf("Directory: %s:\n", argv[ii]);
+            path = _mk_path(argv[ii], PLAYLIST_DIR);
+            if (path == NULL) {
+                fprintf(stderr, "Failed to find playlist path: %s\n", argv[ii]);
+                continue;
+            }
+            dir = opendir(path);
+            if (dir == NULL) {
+                fprintf(stderr, "Failed to open dir: %s\n", path);
+                free(path);
+                continue;
+            }
+        }
+        if (dir != NULL) {
+            char **dirlist = (char**)calloc(10001, sizeof(char*));
+            struct dirent *ent;
+            int jj = 0;
+            for (ent = readdir(dir); ent != NULL; ent = readdir(dir)) {
+                dirlist[jj++] = strcpy((char*)malloc(strlen(ent->d_name)), ent->d_name);
+            }
+            qsort(dirlist, jj, sizeof(char*), _qsort_str_cmp);
+            for (jj = 0; dirlist[jj] != NULL; jj++) {
+                char *name = NULL;
+                name = _mk_path(path, dirlist[jj]);
+                free(dirlist[jj]);
+                if (stat(name, &st)) {
+                    free(name);
+                    continue;
+                }
+                if (!S_ISREG(st.st_mode)) {
+                    free(name);
+                    continue;
+                }
+                pl = _process_file(name, pl_list, pl_ii);
+                free(name);
+                if (pl != NULL) {
+                    pl_list[pl_ii++] = pl;
+                }
+            }
+            free(dirlist);
+            free(path);
+            closedir(dir);
+            dir = NULL;
+        } else {
+            pl = _process_file(argv[ii], pl_list, pl_ii);
+            if (pl != NULL) {
+                pl_list[pl_ii++] = pl;
+            }
+        }
+    }
+    // Cleanup
+    for (ii = 0; ii < pl_ii; ii++) {
+        bd_free_mpls(pl_list[ii]);
+    }
+    return 0;
+}
+
diff --git a/src/devtools/util.c b/src/devtools/util.c
new file mode 100644
index 0000000..aaa4c46
--- /dev/null
+++ b/src/devtools/util.c
@@ -0,0 +1,40 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2009-2010  John Stebbins
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "util.h"
+
+void
+indent_printf(int level, const char *fmt, ...)
+{
+    va_list ap;
+    int ii;
+
+    for (ii = 0; ii < level; ii++)
+    {
+        printf("    ");
+    }
+    va_start(ap, fmt);
+    vprintf(fmt, ap);
+    va_end(ap);
+    printf("\n");
+}
+
diff --git a/src/devtools/util.h b/src/devtools/util.h
new file mode 100644
index 0000000..144f8ec
--- /dev/null
+++ b/src/devtools/util.h
@@ -0,0 +1,43 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2009-2010  John Stebbins
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdint.h>
+
+#include "util/attributes.h"
+
+#if defined( __MINGW32__ )
+#   undef  lseek
+#   define lseek  _lseeki64
+#   undef  fseeko
+#   define fseeko fseeko64
+#   undef  ftello
+#   define ftello ftello64
+#   define flockfile(...)
+#   define funlockfile(...)
+#   define getc_unlocked getc
+#   undef  off_t
+#   define off_t off64_t
+#   undef  stat
+#   define stat  _stati64
+#   define fstat _fstati64
+#   define wstat _wstati64
+#endif
+
+void indent_printf(int level, const char *fmt, ...) BD_ATTR_FORMAT_PRINTF(2,3);
+
diff --git a/src/examples/bdj_test.c b/src/examples/bdj_test.c
deleted file mode 100644
index d9ebd16..0000000
--- a/src/examples/bdj_test.c
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * This file is part of libbluray
- * Copyright (C) 2010  William Hahne
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * In addition, as a special exception, the copyright holders of libbluray
- * gives permission to link the code of its release of libbluray with the
- * OpenSSL project's "OpenSSL" library (or with modified versions of it
- * that use the same license as the "OpenSSL" library), and distribute
- * the linked executables.  You must obey the GNU General Public License
- * in all respects for all of the code used other than "OpenSSL".  If you
- * modify this file, you may extend this exception to your version of the
- * file, but you are not obligated to do so.  If you do not wish to do
- * so, delete this exception statement from your version.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-
-#include "libbluray/bluray.h"
-
-#if defined(_WIN32)
-#include <windows.h>
-#define sleep(x) Sleep(x)
-#endif
-
-static void _usage(void) {
-    printf("Usage: [path to disc] [starting object]\n");
-}
-
-int main(int argc, char** argv)
-{
-    if (argc < 3) {
-        _usage();
-        return 0;
-    }
-
-    printf("%s %s\n", argv[1], argv[2]);
-
-    BLURAY* bd = bd_open(argv[1], NULL);
-
-    bd_get_titles(bd, TITLES_ALL, 0);
-
-    if (!bd_start_bdj(bd, argv[2])) {
-        printf("Failed to start BD-J application.\n");
-    } else {
-        while (1) { sleep(20); }
-        bd_stop_bdj(bd);
-    }
-
-    bd_close(bd);
-
-    return 0;
-}
diff --git a/src/examples/bdjo_dump.c b/src/examples/bdjo_dump.c
deleted file mode 100644
index bcbd2af..0000000
--- a/src/examples/bdjo_dump.c
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- * This file is part of libbluray
- * Copyright (C) 2014  Petri Hintukainen <phintuka@users.sourceforge.net>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#include "libbluray/bluray.h"
-#include "libbluray/bdj/bdjo_data.h"
-
-#include <stdio.h>
-#include <string.h>
-
-static const char *_yes_no(int i)
-{
-    return i > 0 ? "yes" : i < 0 ? "unknown" : "no";
-}
-
-static const char *_binding_str(int i)
-{
-    switch (i) {
-        case 0:  return "unbound";
-        case 1:  return "disc bound";
-        case 3:  return "title bound";
-        default: return "???";
-    }
-}
-
-static const char *_visibility_str(int i)
-{
-    switch (i) {
-        case 0:  return "none";
-        case 1:  return "applications";
-        case 2:  return "user";
-        default: return "???";
-    }
-}
-
-static void _terminal_info_print(const BDJO_TERMINAL_INFO *p)
-{
-    printf("Terminal Info:\n");
-    printf("    Default AWT font    : %s\n", p->default_font);
-    printf("    initial HaVi config : %d\n", p->initial_havi_config_id);
-    printf("    Menu call mask      : %d\n", p->menu_call_mask);
-    printf("    Title search mask   : %d\n", p->menu_call_mask);
-}
-
-static void _app_cache_item_print(const BDJO_APP_CACHE_ITEM *p)
-{
-    printf("    %3.3s: %s%s\n",
-           p->lang_code, p->ref_to_name,
-           p->type == 1 ? ".jar" : p->type == 2 ? "/" : " (unknown type)");
-}
-
-static void _app_cache_info_print(const BDJO_APP_CACHE_INFO *p)
-{
-    unsigned ii;
-
-    printf("Application cache info:\n");
-    for (ii = 0; ii < p->num_item; ii++) {
-        _app_cache_item_print(&p->item[ii]);
-    }
-}
-
-static void _accessible_playlists_print(const BDJO_ACCESSIBLE_PLAYLISTS *p)
-{
-    unsigned ii;
-
-    printf("Accessible playlists:\n");
-    printf("    Access to all       : %s\n", _yes_no(p->access_to_all_flag));
-    printf("    Autostart first     : %s\n", _yes_no(p->autostart_first_playlist_flag));
-
-    if (p->num_pl) {
-        printf("    Playlists           : %d\n", p->num_pl);
-        for (ii = 0; ii < p->num_pl; ii++) {
-            printf("        %s.mpls\n", p->pl[ii].name);
-        }
-    }
-}
-
-static void _app_profile_print(BDJO_APP_PROFILE *p)
-{
-    printf("        Profile %d Version %d.%d.%d\n",
-           p->profile_number, p->major_version, p->minor_version, p->micro_version);
-}
-
-static void _app_print(const BDJO_APP *p)
-{
-    unsigned ii;
-
-    printf("    Control code:       : %d (%s)\n", p->control_code,
-           p->control_code == 1 ? "autostart" : p->control_code == 2 ? "present" : "???");
-    printf("    Type                : %d (%s)\n", p->type,
-           p->type == 1 ? "BD-J App" : "???");
-    printf("    Organization ID     : %08X\n", p->org_id);
-    printf("    Application ID      : %04X\n", p->app_id);
-    printf("    Priority            : %d\n", p->priority);
-    printf("    Binding             : %d (%s)\n", p->binding, _binding_str(p->binding));
-    printf("    Visibility          : %d (%s)\n", p->visibility, _visibility_str(p->visibility));
-
-    if (p->num_profile) {
-        printf("    Profiles:\n");
-        for (ii = 0; ii < p->num_profile; ii++) {
-            _app_profile_print(&p->profile[ii]);
-        }
-    }
-
-    if (p->num_name) {
-        printf("    Names:\n");
-        for (ii = 0; ii < p->num_name; ii++) {
-            printf("        %s: %s\n", p->name[ii].lang, p->name[ii].name);
-        }
-    }
-
-    printf("    Base directory      : %s\n", p->base_dir);
-    printf("    Icon locator        : %s\n", p->icon_locator);
-    printf("    Icon flags          : 0x%04x\n", p->icon_flags);
-    printf("    Classpath extension : %s\n", p->classpath_extension);
-    printf("    Initial class       : %s\n", p->initial_class);
-    printf("    Parameters          : ");
-    for (ii = 0; ii < p->num_param; ii++) {
-        printf("%s ", p->param[ii].param);
-    }
-    printf("\n");
-}
-
-static void _app_management_table_print(const BDJO_APP_MANAGEMENT_TABLE *p)
-{
-    unsigned ii;
-
-    for (ii = 0; ii < p->num_app; ii++) {
-        printf("Application %d:\n", ii);
-        _app_print(&p->app[ii]);
-    }
-}
-
-static void _key_interest_table_print(const BDJO_KEY_INTEREST_TABLE *p)
-{
-    unsigned int v;
-    memcpy(&v, p, sizeof(unsigned int));
-    if (v) {
-        printf("Key interest table:\n");
-        printf("    %s%s%s%s%s%s%s%s%s%s%s\n",
-               p->vk_play              ? "VK_PLAY " : "",
-               p->vk_stop              ? "VK_STOP " : "",
-               p->vk_ffw               ? "VK_FFW " : "",
-               p->vk_rew               ? "VK_REW " : "",
-               p->vk_track_next        ? "VK_TRACK_NEXT " : "",
-               p->vk_track_prev        ? "VK_TRACK_PREV " : "",
-               p->vk_pause             ? "VK_PAUSE " : "",
-               p->vk_still_off         ? "VK_STILL_OFF " : "",
-               p->vk_sec_audio_ena_dis ? "VK_SEC_AUDIO " : "",
-               p->vk_sec_video_ena_dis ? "VK_SEC_VIDEO " : "",
-               p->pg_textst_ena_dis    ? "VK_PG_TEXTST " : "");
-    }
-}
-
-static void _file_access_info_print(const BDJO_FILE_ACCESS_INFO *p)
-{
-    printf("File access info:\n    %s\n",  p->path);
-}
-
-static void _bdjo_print(const BDJO *p)
-{
-    _terminal_info_print(&p->terminal_info);
-    _app_cache_info_print(&p->app_cache_info);
-    _accessible_playlists_print(&p->accessible_playlists);
-    _app_management_table_print(&p->app_table);
-    _key_interest_table_print(&p->key_interest_table);
-    _file_access_info_print(&p->file_access_info);
-}
-
-int main(int argc, const char *argv[])
-{
-    if (argc < 2) {
-        fprintf(stderr, "usage: %s <bdjo_file>\n", argv[0]);
-        return 1;
-    }
-
-    int cnt;
-    for (cnt = 1; cnt < argc; cnt++) {
-
-        printf("%s\n", argv[cnt]);
-
-        BDJO *bdjo = bd_read_bdjo(argv[cnt]);
-        if (bdjo) {
-            _bdjo_print(bdjo);
-            bd_free_bdjo(bdjo);
-        }
-        printf("\n");
-    }
-
-    return 0;
-}
diff --git a/src/examples/clpi_dump.c b/src/examples/clpi_dump.c
deleted file mode 100644
index bd64783..0000000
--- a/src/examples/clpi_dump.c
+++ /dev/null
@@ -1,487 +0,0 @@
-/*
- * This file is part of libbluray
- * Copyright (C) 2009-2010  John Stebbins
- * Copyright (C) 2012-2013  Petri Hintukainen <phintuka@users.sourceforge.net>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <inttypes.h>
-
-#include "libbluray/bdnav/clpi_data.h"
-#include "libbluray/bluray.h"
-
-#include "util.h"
-
-static int verbose;
-
-typedef struct {
-    int value;
-    const char *str;
-} VALUE_MAP;
-
-static inline const char*
-_lookup_str(const VALUE_MAP *map, int val)
-{
-    int ii;
-
-    for (ii = 0; map[ii].str; ii++) {
-        if (val == map[ii].value) {
-            return map[ii].str;
-        }
-    }
-    return "?";
-}
-
-const VALUE_MAP codec_map[] = {
-    {0x01, "MPEG-1 Video"},
-    {0x02, "MPEG-2 Video"},
-    {0x03, "MPEG-1 Audio"},
-    {0x04, "MPEG-2 Audio"},
-    {0x80, "LPCM"},
-    {0x81, "AC-3"},
-    {0x82, "DTS"},
-    {0x83, "TrueHD"},
-    {0x84, "AC-3 Plus"},
-    {0x85, "DTS-HD"},
-    {0x86, "DTS-HD Master"},
-    {0xa1, "AC-3 Plus for secondary audio"},
-    {0xa2, "DTS-HD for secondary audio"},
-    {0xea, "VC-1"},
-    {0x1b, "H.264"},
-    {0x20, "H.264 MVC dep."},
-    {0x90, "Presentation Graphics"},
-    {0x91, "Presentation Graphics"},
-    {0x92, "Interactive Graphics"},
-    {0, NULL}
-};
-
-const VALUE_MAP video_format_map[] = {
-    {0, "Reserved"},
-    {1, "480i"},
-    {2, "576i"},
-    {3, "480p"},
-    {4, "1080i"},
-    {5, "720p"},
-    {6, "1080p"},
-    {7, "576p"},
-    {0, NULL}
-};
-
-const VALUE_MAP video_rate_map[] = {
-    {0, "Reserved1"},
-    {1, "23.976"},
-    {2, "24"},
-    {3, "25"},
-    {4, "29.97"},
-    {5, "Reserved2"},
-    {6, "50"},
-    {7, "59.94"},
-    {0, NULL}
-};
-
-const VALUE_MAP video_aspect_map[] = {
-    {0, "Reserved1"},
-    {1, "Reserved2"},
-    {2, "4:3"},
-    {3, "16:9"},
-    {0, NULL}
-};
-
-const VALUE_MAP audio_format_map[] = {
-    {0, "Reserved1"},
-    {1, "Mono"},
-    {2, "Reserved2"},
-    {3, "Stereo"},
-    {4, "Reserved3"},
-    {5, "Reserved4"},
-    {6, "Multi Channel"},
-    {12, "Combo"},
-    {0, NULL}
-};
-
-const VALUE_MAP audio_rate_map[] = {
-    {0, "Reserved1"},
-    {1, "48 Khz"},
-    {2, "Reserved2"},
-    {3, "Reserved3"},
-    {4, "96 Khz"},
-    {5, "192 Khz"},
-    {12, "48/192 Khz"},
-    {14, "48/96 Khz"},
-    {0, NULL}
-};
-
-const VALUE_MAP application_type_map[] = {
-    {1, "Main TS for a main-path of Movie"},
-    {2, "Main TS for a main-path of Time based slide show"},
-    {3, "Main TS for a main-path of Browsable slide show"},
-    {4, "Sub TS for a sub-path of Browsable slide show"},
-    {5, "Sub TS for a sub-path of Interactive Graphics menu"},
-    {6, "Sub TS for a sub-path of Text subtitle"},
-    {7, "Sub TS for a sub-path of one or more elementary streams path"},
-    {0, NULL},
-};
-
-static void
-_show_stream(CLPI_PROG_STREAM *ss, int level)
-{
-    indent_printf(level, "Codec (%04x): %s", ss->coding_type,
-                    _lookup_str(codec_map, ss->coding_type));
-    indent_printf(level, "PID: %04x", ss->pid);
-    switch (ss->coding_type) {
-        case 0x01:
-        case 0x02:
-        case 0xea:
-        case 0x1b:
-        case 0x20:
-            indent_printf(level, "Format %02x: %s", ss->format,
-                        _lookup_str(video_format_map, ss->format));
-            indent_printf(level, "Rate %02x: %s", ss->rate,
-                        _lookup_str(video_rate_map, ss->rate));
-            indent_printf(level, "Aspect %02x: %s", ss->aspect,
-                        _lookup_str(video_aspect_map, ss->aspect));
-            indent_printf(level, "oc_flag %02x", ss->oc_flag);
-            break;
-
-        case 0x03:
-        case 0x04:
-        case 0x80:
-        case 0x81:
-        case 0x82:
-        case 0x83:
-        case 0x84:
-        case 0x85:
-        case 0x86:
-        case 0xa1:
-        case 0xa2:
-            indent_printf(level, "Format %02x: %s", ss->format,
-                        _lookup_str(audio_format_map, ss->format));
-            indent_printf(level, "Rate %02x: %s", ss->rate,
-                        _lookup_str(audio_rate_map, ss->rate));
-            indent_printf(level, "Language: %s", ss->lang);
-            break;
-
-        case 0x90:
-        case 0x91:
-        case 0xa0:
-            indent_printf(level, "Language: %s", ss->lang);
-            break;
-
-        case 0x92:
-            indent_printf(level, "Char Code: %02x", ss->char_code);
-            indent_printf(level, "Language: %s", ss->lang);
-            break;
-
-        default:
-            fprintf(stderr, "unrecognized coding type %02x\n", ss->coding_type);
-            break;
-    };
-}
-
-static void
-_show_clip_info(CLPI_CL *cl, int level)
-{
-    CLPI_CLIP_INFO *ci = &cl->clip;
-    int ii;
-
-    indent_printf(level, "Clip Info");
-    indent_printf(level+1, "Clip Stream Type: %02x", ci->clip_stream_type);
-    indent_printf(level+1, "Clip Application Type (%02x): %s",
-                  ci->application_type, _lookup_str(application_type_map, ci->application_type));
-    indent_printf(level+1, "is_ATC_delta: %s", ci->is_atc_delta ? "True" : "False");
-    indent_printf(level+1, "ATC delta count: %d", ci->atc_delta_count);
-    indent_printf(level+1, "TS Recording Rate: %u", ci->ts_recording_rate);
-    indent_printf(level+1, "Number Source Packets: %u", ci->num_source_packets);
-    // Show ts type info
-    indent_printf(level+1, "TS Type Info");
-    indent_printf(level+2, "Validity Flags %02x", ci->ts_type_info.validity);
-    indent_printf(level+2, "Format Id %s", ci->ts_type_info.format_id);
-    // Show cc5 thing
-    for (ii = 0; ii < ci->atc_delta_count; ii++) {
-        indent_printf(level+1, "ATC delta[ %d ]", ii);
-        indent_printf(level+2, "Delta %08x", ci->atc_delta[ii].delta);
-        indent_printf(level+2, "File Id %s", ci->atc_delta[ii].file_id);
-        indent_printf(level+2, "File Code %s", ci->atc_delta[ii].file_code);
-    }
-    // show fonts
-    if (cl->font_info.font_count) {
-        indent_printf(level+1, "Font files");
-        for (ii = 0; ii < cl->font_info.font_count; ii++) {
-            indent_printf(level+2, "Font file %d: %s.otf", ii+1, cl->font_info.font[ii].file_id);
-        }
-    }
-
-    printf("\n");
-}
-
-static void
-_show_seq_info(CLPI_SEQ_INFO *si, int level)
-{
-    CLPI_ATC_SEQ *atc;
-    CLPI_STC_SEQ *stc;
-    int ii, jj;
-
-    indent_printf(level, "Sequence Info");
-    indent_printf(level+1, "Number ATC Sequences: %d", si->num_atc_seq);
-    for (ii = 0; ii < si->num_atc_seq; ii++) {
-        atc = &si->atc_seq[ii];
-        indent_printf(level+1, "ATC Sequence %d", ii);
-        indent_printf(level+2, "SPN ATC Start: %u", atc->spn_atc_start);
-        indent_printf(level+2, "Offset STC Id: %d", atc->offset_stc_id);
-        indent_printf(level+2, "Number STC Sequences: %d", atc->num_stc_seq);
-        for (jj = 0; jj < atc->num_stc_seq; jj++) {
-            stc = &atc->stc_seq[jj];
-            indent_printf(level+2, "ATC Sequence %d", jj);
-            indent_printf(level+3, "SPN STC Start: %u", stc->spn_stc_start);
-            indent_printf(level+3, "PCR PID: %04x", stc->pcr_pid);
-            indent_printf(level+3, "Presentation Start: %u", 
-                            stc->presentation_start_time);
-            indent_printf(level+3, "Presentation End: %u", 
-                            stc->presentation_end_time);
-        }
-    }
-}
-
-static void
-_show_prog_info(CLPI_PROG_INFO *pi, int level)
-{
-    CLPI_PROG *prog;
-    int ii, jj;
-
-    indent_printf(level, "Program Info");
-    indent_printf(level+1, "Number Programs: %d", pi->num_prog);
-    for (ii = 0; ii < pi->num_prog; ii++) {
-        prog = &pi->progs[ii];
-        indent_printf(level+1, "Program %d", ii);
-        indent_printf(level+2, "SPN Program Sequence Start: %d", 
-                        prog->spn_program_sequence_start);
-        indent_printf(level+2, "Program Map PID: %d", prog->program_map_pid);
-        indent_printf(level+2, "Number Streams: %d", prog->num_streams);
-        indent_printf(level+2, "Number Groups: %d", prog->num_groups);
-        for (jj = 0; jj < prog->num_streams; jj++) {
-            indent_printf(level+2, "Stream %d", jj);
-            _show_stream(&prog->streams[jj], level+3);
-        }
-    }
-}
-
-static void
-_show_extent_start(CLPI_EXTENT_START *es, int level)
-{
-    unsigned int ii;
-
-    indent_printf(level, "Extension data: Extent Start Point");
-
-    if (!es->num_point) {
-        indent_printf(level+1, "(no data)");
-
-    } else {
-        indent_printf(level+1, "Number of Start Points: %d", es->num_point);
-
-        if (verbose) {
-            for (ii = 0; ii < es->num_point; ii++) {
-                indent_printf(level+1, "Extent %5d: SPN 0x%08X", ii, es->point[ii]);
-            }
-        }
-    }
-}
-
-static void
-_show_cpi_info(CLPI_CPI *cpi, int level)
-{
-    CLPI_EP_MAP_ENTRY *entry;
-    CLPI_EP_COARSE *coarse;
-    CLPI_EP_FINE *fine;
-    int ii, jj, kk;
-
-    indent_printf(level, "CPI");
-    indent_printf(level+1, "Number Stream PID: %d", cpi->num_stream_pid);
-    for (ii = 0; ii < cpi->num_stream_pid; ii++) {
-        entry = &cpi->entry[ii];
-        indent_printf(level+1, "Stream: %d", ii);
-        indent_printf(level+2, "PID: %04x", entry->pid);
-        indent_printf(level+2, "EP Stream Type: %d", entry->ep_stream_type);
-        indent_printf(level+2, "Number EP Coarse: %d", entry->num_ep_coarse);
-        indent_printf(level+2, "Number EP Fine: %d", entry->num_ep_fine);
-        indent_printf(level+2, "EP Map Start: %d", 
-                        entry->ep_map_stream_start_addr);
-        for (jj = 0; jj < entry->num_ep_coarse; jj++) {
-            coarse = &entry->coarse[jj];
-            indent_printf(level+2, "Coarse: %d", jj);
-            indent_printf(level+3, "Ref EP Fine: %d", coarse->ref_ep_fine_id);
-            indent_printf(level+3, "PTS EP: %d", coarse->pts_ep);
-            indent_printf(level+3, "SPN EP: %d", coarse->spn_ep);
-        }
-        for (jj = 0; jj < entry->num_ep_fine; jj++) {
-            fine = &entry->fine[jj];
-            indent_printf(level+2, "Fine: %d", jj);
-            indent_printf(level+3, "Angle Change Point: %s", 
-                fine->is_angle_change_point ? "True":"False");
-            indent_printf(level+3, "I End Offset: %d", 
-                fine->i_end_position_offset);
-            indent_printf(level+3, "PTS EP: %d", fine->pts_ep);
-            indent_printf(level+3, "SPN EP: %d", fine->spn_ep);
-        }
-        if (verbose) {
-            uint64_t pts;
-            uint32_t spn;
-
-            indent_printf(level+2, "PTS - SPN Map");
-            for (jj = 0; jj < entry->num_ep_coarse; jj++) {
-                int start, end;
-
-                indent_printf(level+3, "Coarse: %d", jj);
-                coarse = &entry->coarse[jj];
-                start = coarse->ref_ep_fine_id;
-                if (jj < entry->num_ep_coarse - 1) {
-                    end = entry->coarse[jj+1].ref_ep_fine_id;
-                } else {
-                    end = entry->num_ep_fine;
-                }
-                for (kk = start; kk < end; kk++) {
-                    fine = &entry->fine[kk];
-                    pts = ((uint64_t) (coarse->pts_ep & ~0x01) << 19) +
-                            ((uint64_t)fine->pts_ep << 9);
-                    spn = (coarse->spn_ep & ~0x1FFFF) + fine->spn_ep;
-                    indent_printf(level+4, "PTS %8"PRIu64"/%8"PRIu64" -- SPN %u",
-                        pts, pts >> 1, spn);
-                }
-            }
-        }
-    }
-}
-
-
-static void
-_usage(char *cmd)
-{
-    fprintf(stderr, 
-"Usage: %s -vcspi <clpi file> [<clpi file> ...]\n"
-"With no options, produces no output (not very useful)\n"
-"Options:\n"
-"    v - Verbose output.\n"
-"    c - Shows the Clip Info structure\n"
-"    s - Shows the Sequence Info structure\n"
-"    p - Shows the Program Info structure\n"
-"    i - Shows the CPI. PTS to SPN map\n"
-"    e - Shows Extent Start Table\n"
-, cmd);
-
-    exit(EXIT_FAILURE);
-}
-
-#define OPTS "vcspie"
-
-int
-main(int argc, char *argv[])
-{
-    CLPI_CL *cl;
-    int opt;
-    int opt_clip_info = 0, opt_seq_info = 0, opt_prog_info = 0;
-    int opt_cpi_info = 0, opt_extent_start = 0;
-    int ii;
-
-    do {
-        opt = getopt(argc, argv, OPTS);
-        switch (opt) {
-            case -1: break;
-
-            case 'v':
-                verbose = 1;
-                break;
-
-            case 's':
-                opt_seq_info = 1;
-                break;
-
-            case 'i':
-                opt_cpi_info = 1;
-                break;
-
-            case 'c':
-                opt_clip_info = 1;
-                break;
-
-            case 'p':
-                opt_prog_info = 1;
-                break;
-
-            case 'e':
-                opt_extent_start = 1;
-                break;
-
-            default:
-                _usage(argv[0]);
-                break;
-        }
-    } while (opt != -1);
-
-    if (optind >= argc) {
-        _usage(argv[0]);
-    }
-
-    for (ii = optind; ii < argc; ii++) {
-        cl = bd_read_clpi(argv[ii]);
-        if (cl == NULL) {
-            fprintf(stderr, "Parsing %s failed\n", argv[ii]);
-            continue;
-        }
-        if (opt_clip_info) {
-            // Show clip info
-            _show_clip_info(cl, 1);
-        }
-        if (opt_seq_info) {
-            // Show sequence info
-            _show_seq_info(&cl->sequence, 1);
-        }
-        if (opt_prog_info) {
-            // Show program info
-            _show_prog_info(&cl->program, 1);
-        }
-        if (opt_cpi_info) {
-            // Show cpi
-            _show_cpi_info(&cl->cpi, 1);
-        }
-
-        if (opt_prog_info) {
-            if (cl->program_ss.num_prog) {
-                printf("\n");
-                indent_printf(1, "Extension: Program Info SS");
-                _show_prog_info(&cl->program_ss, 1);
-            }
-        }
-        if (opt_cpi_info) {
-            if (cl->program_ss.num_prog) {
-                printf("\n");
-                indent_printf(1, "Extension: CPI SS");
-                _show_cpi_info(&cl->cpi_ss, 1);
-            }
-        }
-        if (opt_extent_start) {
-            // Show extent start point
-            if (cl->extent_start.num_point > 0) {
-                _show_extent_start(&cl->extent_start, 1);
-            }
-        }
-
-        bd_free_clpi(cl);
-    }
-    return 0;
-}
-
diff --git a/src/examples/hdmv_test.c b/src/examples/hdmv_test.c
deleted file mode 100644
index 585ed70..0000000
--- a/src/examples/hdmv_test.c
+++ /dev/null
@@ -1,257 +0,0 @@
-/*
- * This file is part of libbluray
- * Copyright (C) 2010  hpi1
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <inttypes.h>
-
-#include "util/log_control.h"
-#include "libbluray/bluray.h"
-
-static void _print_event(BD_EVENT *ev)
-{
-    switch (ev->event) {
-        case BD_EVENT_NONE:
-            break;
-        case BD_EVENT_ERROR:
-            printf("EVENT_ERROR:\t%d\n", ev->param);
-            break;
-        case BD_EVENT_READ_ERROR:
-            printf("EVENT_READ_ERROR:\t%d\n", ev->param);
-            break;
-        case BD_EVENT_ENCRYPTED:
-            printf("EVENT_ENCRYPTED:\t%d\n", ev->param);
-            break;
-
-        /* current playback position */
-
-        case BD_EVENT_ANGLE:
-            printf("EVENT_ANGLE:\t%d\n", ev->param);
-            break;
-        case BD_EVENT_TITLE:
-            printf("EVENT_TITLE:\t%d\n", ev->param);
-            break;
-        case BD_EVENT_PLAYLIST:
-            printf("EVENT_PLAYLIST:\t%d\n", ev->param);
-            break;
-        case BD_EVENT_PLAYITEM:
-            printf("EVENT_PLAYITEM:\t%d\n", ev->param);
-            break;
-        case BD_EVENT_CHAPTER:
-            printf("EVENT_CHAPTER:\t%d\n", ev->param);
-            break;
-
-        /* */
-
-        case BD_EVENT_STILL:
-            printf("EVENT_STILL:\t%d\n", ev->param);
-            break;
-
-        case BD_EVENT_SEEK:
-            printf("EVENT_SEEK:\t%d\n", ev->param);
-            break;
-
-        case BD_EVENT_STILL_TIME:
-            if (ev->param) {
-                printf("EVENT_STILL_TIME:\t%d\n", ev->param);
-            } else {
-                printf("EVENT_STILL_TIME:\tinfinite\n");
-            }
-            break;
-
-        /* stream selection */
-
-        case BD_EVENT_AUDIO_STREAM:
-            printf("EVENT_AUDIO_STREAM:\t%d\n", ev->param);
-            break;
-        case BD_EVENT_IG_STREAM:
-            printf("EVENT_IG_STREAM:\t%d\n", ev->param);
-            break;
-        case BD_EVENT_PG_TEXTST_STREAM:
-            printf("EVENT_PG_TEXTST_STREAM:\t%d\n", ev->param);
-            break;
-        case BD_EVENT_SECONDARY_AUDIO_STREAM:
-            printf("EVENT_SECONDARY_AUDIO_STREAM:\t%d\n", ev->param);
-            break;
-        case BD_EVENT_SECONDARY_VIDEO_STREAM:
-            printf("EVENT_SECONDARY_VIDEO_STREAM:\t%d\n", ev->param);
-            break;
-
-        case BD_EVENT_PG_TEXTST:
-            printf("EVENT_PG_TEXTST:\t%s\n", ev->param ? "enable" : "disable");
-            break;
-        case BD_EVENT_SECONDARY_AUDIO:
-            printf("EVENT_SECONDARY_AUDIO:\t%s\n", ev->param ? "enable" : "disable");
-            break;
-        case BD_EVENT_SECONDARY_VIDEO:
-            printf("EVENT_SECONDARY_VIDEO:\t%s\n", ev->param ? "enable" : "disable");
-            break;
-        case BD_EVENT_SECONDARY_VIDEO_SIZE:
-            printf("EVENT_SECONDARY_VIDEO_SIZE:\t%s\n", ev->param==0 ? "PIP" : "fullscreen");
-            break;
-
-        default:
-            printf("UNKNOWN EVENT %d:\t%d\n", ev->event, ev->param);
-            break;
-      }
-
-      fflush(stdout);
-}
-
-static void _read_to_eof(BLURAY *bd)
-{
-    BD_EVENT ev;
-    int      bytes;
-    uint64_t total = 0;
-    uint8_t  buf[6144];
-
-    bd_seek(bd, bd_get_title_size(bd) - 6144);
-
-    do {
-        bytes = bd_read_ext(bd, buf, 6144, &ev);
-        total += bytes < 0 ? 0 : bytes;
-        _print_event(&ev);
-    } while (bytes > 0);
-
-    printf("_read_to_eof(): read %"PRIu64" bytes\n", total);
-}
-
-static void _print_events(BLURAY *bd)
-{
-    BD_EVENT ev;
-
-    do {
-        bd_read_ext(bd, NULL, 0, &ev);
-        _print_event(&ev);
-    } while (ev.event != BD_EVENT_NONE && ev.event != BD_EVENT_ERROR);
-}
-
-static void _play_pl(BLURAY *bd)
-{
-    printf("Playing playlist\n");
-
-    fflush(stdout);
-    _read_to_eof(bd);
-
-    printf("Playing playlist done\n\n");
-
-    _print_events(bd);
-
-    printf("\n");
-}
-
-int main(int argc, char *argv[])
-{
-    int title = -1;
-    int verbose = 0;
-    int args = 0;
-
-    /*
-     * parse arguments
-     */
-
-    if (argc < 2) {
-        printf("\nUsage:\n   %s [-v] [-t <title>] <media_path> [<keyfile_path>]\n\n", argv[0]);
-        return -1;
-    }
-
-    if (!strcmp(argv[1+args], "-v")) {
-        verbose = 1;
-        args++;
-    }
-
-    if (!strcmp(argv[1+args], "-t")) {
-        args++;
-        title = atoi(argv[1+args]);
-        args++;
-        printf("Requested title %d\n", title);
-    }
-
-    if (verbose) {
-        printf("Enabling verbose debug\n");
-        bd_set_debug_mask(bd_get_debug_mask() | DBG_HDMV | DBG_BLURAY);
-    }
-
-    printf("\n");
-
-    /*
-     * open and setup
-     */
-
-    BLURAY  *bd = bd_open(argv[1+args], argv[2+args]);
-
-    if (!bd) {
-        printf("bd_open(\'%s\') failed\n", argv[1]);
-        return -1;
-    }
-
-    bd_set_player_setting    (bd, BLURAY_PLAYER_SETTING_PARENTAL,     99);
-    bd_set_player_setting_str(bd, BLURAY_PLAYER_SETTING_AUDIO_LANG,   "eng");
-    bd_set_player_setting_str(bd, BLURAY_PLAYER_SETTING_PG_LANG,      "eng");
-    bd_set_player_setting_str(bd, BLURAY_PLAYER_SETTING_MENU_LANG,    "eng");
-    bd_set_player_setting_str(bd, BLURAY_PLAYER_SETTING_COUNTRY_CODE, NULL);
-
-    /*
-     * play
-     */
-
-    printf("Running first play movie object\n");
-
-    fflush(stdout);
-    bd_play(bd);
-
-    _print_events(bd);
-
-    printf("\n");
-
-    /*
-     * play title
-     */
-
-    if (title >= 0) {
-        printf("Playing title %d\n", title);
-
-        fflush(stdout);
-        bd_play_title(bd, title);
-
-        _print_events(bd);
-
-        printf("\n");
-    }
-
-    /*
-     * play playlist
-     */
-
-    _play_pl(bd);
-
-    _play_pl(bd);
-
-    _play_pl(bd);
-
-    /*
-     * clean up
-     */
-
-    bd_close(bd);
-
-    return 0;
-}
-
diff --git a/src/examples/list_titles.c b/src/examples/list_titles.c
index 2e0cae8..768f078 100644
--- a/src/examples/list_titles.c
+++ b/src/examples/list_titles.c
@@ -78,7 +78,10 @@ int main(int argc, char *argv[])
         _usage(argv[0]);
     }
     bd = bd_open(bd_dir, NULL);
-
+    if (!bd) {
+        fprintf(stderr, "bd_open(%s) failed\n", bd_dir);
+        exit(EXIT_FAILURE);
+    }
     count = bd_get_titles(bd, flags, seconds);
     main_title = bd_get_main_title(bd);
     if (main_title >= 0) {
@@ -89,7 +92,7 @@ int main(int argc, char *argv[])
         BLURAY_TITLE_INFO* ti;
         ti = bd_get_title_info(bd, ii, 0);
         printf(
-       "index: %d duration: %02"PRIu64":%02"PRIu64":%02"PRIu64" chapters: %3d angles: %2u clips: %3u (playlist: %05d.mpls) "
+       "index: %3d duration: %02"PRIu64":%02"PRIu64":%02"PRIu64" chapters: %3d angles: %2u clips: %3u (playlist: %05d.mpls) "
        "V:%d A:%-2d PG:%-2d IG:%-2d SV:%d SA:%d\n",
               ii + 1,
               (ti->duration / 90000) / (3600),
diff --git a/src/examples/mobj_dump.c b/src/examples/mobj_dump.c
deleted file mode 100644
index 3eaf9f4..0000000
--- a/src/examples/mobj_dump.c
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * This file is part of libbluray
- * Copyright (C) 2010  hpi1
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#include "libbluray/bluray.h"
-
-#include "libbluray/hdmv/mobj_data.h"
-#include "libbluray/hdmv/mobj_print.h"
-
-#include <stdio.h>
-#include <string.h>
-
-static void _mobj_print(MOBJ_OBJECTS *objects, int disasm)
-{
-    int o, c;
-
-    printf("Number of objects: %d\n", objects->num_objects);
-
-    for (o = 0; o < objects->num_objects; o++) {
-
-        printf("Object %d:\n"
-               "  number of commands:    %d\n"
-               "  resume intention flag: %d\n"
-               "  menu call mask:        %d\n"
-               "  title search mask:     %d\n",
-               o, objects->objects[o].num_cmds,
-               objects->objects[o].resume_intention_flag,
-               objects->objects[o].menu_call_mask,
-               objects->objects[o].title_search_mask);
-
-            if (disasm) {
-                printf("  program:\n");
-                for (c = 0; c < objects->objects[o].num_cmds; c++) {
-                    char buf[256];
-                    mobj_sprint_cmd(buf, &objects->objects[o].cmds[c]);
-                    printf("    %04d: %s\n", c, buf);
-                }
-            }
-    }
-}
-
-int main(int argc, const char *argv[])
-{
-    int           disasm = 0;
-    MOBJ_OBJECTS *mobj = NULL;
-
-    if (argc < 2) {
-        fprintf(stderr,
-                "usage: %s [-d] <file>\n"
-                "Options:\n"
-                "    d         disassemble object code\n",
-                argv[0]);
-        return 1;
-    }
-    if (argc > 2) {
-        disasm = !strcmp(argv[1], "-d");
-    }
-
-    mobj = bd_read_mobj(argv[argc-1]);
-
-    if (mobj) {
-        _mobj_print(mobj, disasm);
-
-        bd_free_mobj(mobj);
-    }
-
-    return 0;
-}
diff --git a/src/examples/mpls_dump.c b/src/examples/mpls_dump.c
deleted file mode 100644
index 619b6b2..0000000
--- a/src/examples/mpls_dump.c
+++ /dev/null
@@ -1,797 +0,0 @@
-/*
- * This file is part of libbluray
- * Copyright (C) 2009-2010  John Stebbins
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#include <sys/stat.h>
-#include <dirent.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include <libgen.h>
-
-#include "libbluray/bdnav/mpls_parse.h"
-#include "libbluray/bluray.h"
-
-#include "util.h"
-
-#ifdef _WIN32
-# define DIR_SEP "\\"
-# define PLAYLIST_DIR "\\BDMV\\PLAYLIST"
-#else
-# define DIR_SEP "/"
-# define PLAYLIST_DIR "/BDMV/PLAYLIST"
-#endif
-
-
-static int verbose;
-
-typedef struct {
-    int value;
-    const char *str;
-} VALUE_MAP;
-
-const VALUE_MAP codec_map[] = {
-    {0x01, "MPEG-1 Video"},
-    {0x02, "MPEG-2 Video"},
-    {0x03, "MPEG-1 Audio"},
-    {0x04, "MPEG-2 Audio"},
-    {0x80, "LPCM"},
-    {0x81, "AC-3"},
-    {0x82, "DTS"},
-    {0x83, "TrueHD"},
-    {0x84, "AC-3 Plus"},
-    {0x85, "DTS-HD"},
-    {0x86, "DTS-HD Master"},
-    {0xa1, "AC-3 Plus for secondary audio"},
-    {0xa2, "DTS-HD for secondary audio"},
-    {0xea, "VC-1"},
-    {0x1b, "H.264"},
-    {0x90, "Presentation Graphics"},
-    {0x91, "Interactive Graphics"},
-    {0x92, "Text Subtitle"},
-    {0, NULL}
-};
-
-const VALUE_MAP video_format_map[] = {
-    {0, "Reserved"},
-    {1, "480i"},
-    {2, "576i"},
-    {3, "480p"},
-    {4, "1080i"},
-    {5, "720p"},
-    {6, "1080p"},
-    {7, "576p"},
-    {0, NULL}
-};
-
-const VALUE_MAP video_rate_map[] = {
-    {0, "Reserved1"},
-    {1, "23.976"},
-    {2, "24"},
-    {3, "25"},
-    {4, "29.97"},
-    {5, "Reserved2"},
-    {6, "50"},
-    {7, "59.94"},
-    {0, NULL}
-};
-
-const VALUE_MAP audio_format_map[] = {
-    {0, "Reserved1"},
-    {1, "Mono"},
-    {2, "Reserved2"},
-    {3, "Stereo"},
-    {4, "Reserved3"},
-    {5, "Reserved4"},
-    {6, "Multi Channel"},
-    {12, "Combo"},
-    {0, NULL}
-};
-
-const VALUE_MAP audio_rate_map[] = {
-    {0, "Reserved1"},
-    {1, "48 Khz"},
-    {2, "Reserved2"},
-    {3, "Reserved3"},
-    {4, "96 Khz"},
-    {5, "192 Khz"},
-    {12, "48/192 Khz"},
-    {14, "48/96 Khz"},
-    {0, NULL}
-};
-
-const VALUE_MAP subpath_type_map[] = {
-  {2, "Primary audio of the Browsable slideshow"},
-  {3, "Interactive Graphics presentation menu"},
-  {4, "Text Subtitle"},
-  {5, "Out-of-mux Synchronous elementary streams"},
-  {6, "Out-of-mux Asynchronous Picture-in-Picture presentation"},
-  {7, "In-mux Synchronous Picture-in-Picture presentation"},
-  {8, "SS Video"},
-  {0,NULL}
-};
-
-const VALUE_MAP playback_type_map[] = {
-  {1, "Sequential"},
-  {2, "Random"},
-  {3, "Shuffle"},
-  {0, NULL}
-};
-
-const VALUE_MAP connection_type_map[] = {
-  {1, "Non-seamless"},
-  {5, "Seamless"},
-  {6, "Seamless"},
-  {0, NULL}
-};
-
-static const char*
-_lookup_str(const VALUE_MAP *map, int val)
-{
-    int ii;
-
-    for (ii = 0; map[ii].str; ii++) {
-        if (val == map[ii].value) {
-            return map[ii].str;
-        }
-    }
-    return "?";
-}
-
-static char *
-_mk_path(const char *base, const char *sub)
-{
-    size_t n1 = strlen(base);
-    size_t n2 = strlen(sub);
-    char *result = (char*)malloc(n1 + n2 + strlen(DIR_SEP) + 1);
-    strcpy(result, base);
-    strcat(result, DIR_SEP);
-    strcat(result, sub);
-
-    return result;
-}
-
-static void
-_show_stream(MPLS_STREAM *ss, int level)
-{
-    indent_printf(level, "Codec (%04x): %s", ss->coding_type,
-                    _lookup_str(codec_map, ss->coding_type));
-    switch (ss->stream_type) {
-        case 1:
-            indent_printf(level, "PID: %04x", ss->pid);
-            break;
-
-        case 2:
-        case 4:
-            indent_printf(level, "SubPath Id: %02x", ss->subpath_id);
-            indent_printf(level, "SubClip Id: %02x", ss->subclip_id);
-            indent_printf(level, "PID: %04x", ss->pid);
-            break;
-
-        case 3:
-            indent_printf(level, "SubPath Id: %02x", ss->subpath_id);
-            indent_printf(level, "PID: %04x", ss->pid);
-            break;
-
-        default:
-            fprintf(stderr, "unrecognized stream type %02x\n", ss->stream_type);
-            break;
-    };
-
-    switch (ss->coding_type) {
-        case 0x01:
-        case 0x02:
-        case 0xea:
-        case 0x1b:
-            indent_printf(level, "Format %02x: %s", ss->format,
-                        _lookup_str(video_format_map, ss->format));
-            indent_printf(level, "Rate %02x: %s", ss->rate,
-                        _lookup_str(video_rate_map, ss->rate));
-            break;
-
-        case 0x03:
-        case 0x04:
-        case 0x80:
-        case 0x81:
-        case 0x82:
-        case 0x83:
-        case 0x84:
-        case 0x85:
-        case 0x86:
-        case 0xa1:
-        case 0xa2:
-            indent_printf(level, "Format %02x: %s", ss->format,
-                        _lookup_str(audio_format_map, ss->format));
-            indent_printf(level, "Rate %02x: %s", ss->rate,
-                        _lookup_str(audio_rate_map, ss->rate));
-            indent_printf(level, "Language: %s", ss->lang);
-            break;
-
-        case 0x90:
-        case 0x91:
-            indent_printf(level, "Language: %s", ss->lang);
-            break;
-
-        case 0x92:
-            indent_printf(level, "Char Code: %02x", ss->char_code);
-            indent_printf(level, "Language: %s", ss->lang);
-            break;
-
-        default:
-            fprintf(stderr, "unrecognized coding type %02x\n", ss->coding_type);
-            break;
-    };
-}
-
-static void
-_show_details(MPLS_PL *pl, int level)
-{
-    int ii, jj, kk;
-
-    for (ii = 0; ii < pl->list_count; ii++) {
-        MPLS_PI *pi;
-
-        pi = &pl->play_item[ii];
-        indent_printf(level, "Clip Id %s", pi->clip[0].clip_id);
-        indent_printf(level+1, "Stc Id: %02x", pi->clip[0].stc_id);
-        indent_printf(level+1, "Connection Condition: %s (%02x)",
-                      _lookup_str(connection_type_map, pi->connection_condition),
-                      pi->connection_condition);
-        indent_printf(level+1, "In-Time: %d", pi->in_time);
-        indent_printf(level+1, "Out-Time: %d", pi->out_time);
-        if (pi->still_mode == 1) {
-            indent_printf(level+1, "Still time: %ds\n", pi->still_time);
-        }
-        if (pi->still_mode == 2) {
-            indent_printf(level+1, "Still time: infinite\n");
-        }
-        if (pi->angle_count > 1) {
-            for (jj = 1; jj < pi->angle_count; jj++) {
-                indent_printf(level+1, "Angle %d:", jj);
-                indent_printf(level+2, "Clip Id %s", pi->clip[jj].clip_id);
-                indent_printf(level+2, "Stc Id: %02x", pi->clip[jj].stc_id);
-            }
-        }
-        for (jj = 0; jj < pi->stn.num_video; jj++) {
-            indent_printf(level+1, "Video Stream %d:", jj);
-            _show_stream(&pi->stn.video[jj], level + 2);
-        }
-        for (jj = 0; jj < pi->stn.num_audio; jj++) {
-            indent_printf(level+1, "Audio Stream %d:", jj);
-            _show_stream(&pi->stn.audio[jj], level + 2);
-        }
-        for (jj = 0; jj < pi->stn.num_ig; jj++) {
-            indent_printf(level+1, "Interactive Graphics Stream %d:", jj);
-            _show_stream(&pi->stn.ig[jj], level + 2);
-        }
-        for (jj = 0; jj < (pi->stn.num_pg + pi->stn.num_pip_pg); jj++) {
-            if (jj < pi->stn.num_pg) {
-               indent_printf(level+1, "Presentation Graphics Stream %d:", jj);
-            } else {
-                indent_printf(level+1, "PIP Presentation Graphics Stream %d:", jj);
-            }
-            _show_stream(&pi->stn.pg[jj], level + 2);
-        }
-        for (jj = 0; jj < pi->stn.num_secondary_video; jj++) {
-            indent_printf(level+1, "Secondary Video Stream %d:", jj);
-            _show_stream(&pi->stn.secondary_video[jj], level + 2);
-            for (kk = 0; kk < pi->stn.secondary_video[jj].sv_num_secondary_audio_ref; kk++) {
-                indent_printf(level+2, "Secondary Audio Ref %d: %d", kk,pi->stn.secondary_video[jj].sv_secondary_audio_ref[kk]);
-            }
-            for (kk = 0; kk < pi->stn.secondary_video[jj].sv_num_pip_pg_ref; kk++) {
-                indent_printf(level+2, "PIP Presentation Graphic Ref %d: %d", kk,pi->stn.secondary_video[jj].sv_pip_pg_ref[kk]);
-            }
-        }
-        for (jj = 0; jj < pi->stn.num_secondary_audio; jj++) {
-            indent_printf(level+1, "Secondary Audio Stream %d:", jj);
-            _show_stream(&pi->stn.secondary_audio[jj], level + 2);
-            for (kk = 0; kk < pi->stn.secondary_audio[jj].sa_num_primary_audio_ref; kk++) {
-                indent_printf(level+2, "Primary Audio Ref %d: %d", kk,pi->stn.secondary_audio[jj].sa_primary_audio_ref[kk]);
-            }
-        }
-        printf("\n");
-    }
-}
-
-static void
-_show_ai(MPLS_PL *pl, int level)
-{
-    indent_printf(level, "Playback type: %s (%d)",
-                  _lookup_str(playback_type_map, pl->app_info.playback_type),
-                  pl->app_info.playback_type);
-    if (pl->app_info.playback_type == 2 || pl->app_info.playback_type == 3) {
-        indent_printf(level+1, "Playback count: %d", pl->app_info.playback_count);
-    }
-}
-
-static void
-_show_marks(MPLS_PL *pl, int level)
-{
-    int ii;
-
-    indent_printf(level, "PlayMark Count %d", pl->mark_count);
-    for (ii = 0; ii < pl->mark_count; ii++) {
-        MPLS_PI *pi;
-        MPLS_PLM *plm;
-        int min;
-        double sec;
-
-        plm = &pl->play_mark[ii];
-        indent_printf(level, "PlayMark %d", ii);
-        indent_printf(level+1, "Type: %02x", plm->mark_type);
-        if (plm->play_item_ref < pl->list_count) {
-            pi = &pl->play_item[plm->play_item_ref];
-            indent_printf(level+1, "PlayItem: %s", pi->clip[0].clip_id);
-        } else {
-            indent_printf(level+1, "PlayItem: Invalid reference");
-        }
-        indent_printf(level+1, "Time (ticks): %u", plm->time);
-        min = plm->duration / (45000*60);
-        sec = (double)(plm->duration - min * 45000 * 60) / 45000;
-        indent_printf(level+1, "Duration (mm:ss.ms, ticks): %d:%.2f, %u",
-                      min, sec, plm->duration);
-        printf("\n");
-    }
-}
-
-static void
-_show_clip_list(MPLS_PL *pl, int level)
-{
-    int ii, jj;
-
-    for (ii = 0; ii < pl->list_count; ii++) {
-        MPLS_PI *pi;
-
-        pi = &pl->play_item[ii];
-        if (verbose) {
-            uint32_t duration;
-
-            duration = pi->out_time - pi->in_time;
-            indent_printf(level, "%s.m2ts -- Duration: %3d:%02d", 
-                        pi->clip[0].clip_id,
-                        duration / (45000 * 60), (duration / 45000) % 60);
-        } else {
-            indent_printf(level, "%s.m2ts", pi->clip[0].clip_id);
-        }
-        if (pi->angle_count > 1) {
-            for (jj = 1; jj < pi->angle_count; jj++) {
-                indent_printf(level+1, "Angle %d: %s.m2ts", jj+1, pi->clip[jj].clip_id);
-            }
-        }
-    }
-    printf("\n");
-}
-
-static void
-_show_sub_path(MPLS_SUB *sub, int level)
-{
-    int ii;
-
-    indent_printf(level+1, "Type: %d (%s)", sub->type, _lookup_str(subpath_type_map, sub->type));
-    indent_printf(level+1, "Repeat: %d", sub->is_repeat);
-    indent_printf(level+1, "Sub playitem count: %d", sub->sub_playitem_count);
-
-    for (ii = 0; ii < sub->sub_playitem_count; ii++) {
-        MPLS_SUB_PI *pi;
-
-        pi = &sub->sub_play_item[ii];
-
-        if (verbose) {
-            indent_printf(level+1, "Sub playitem %d", ii);
-            indent_printf(level+2, "Clip Id %s", pi->clip[0].clip_id);
-            indent_printf(level+2, "Multi clip: %d", pi->is_multi_clip);
-            indent_printf(level+2, "Clip count: %d", pi->clip_count);
-            indent_printf(level+2, "Connection Condition: %s (%02x)",
-                          _lookup_str(connection_type_map, pi->connection_condition),
-                          pi->connection_condition);
-            indent_printf(level+2, "In-Time: %d", pi->in_time);
-            indent_printf(level+2, "Out-Time: %d", pi->out_time);
-            indent_printf(level+2, "Sync playitem Id: %d", pi->sync_play_item_id);
-            indent_printf(level+2, "Sync PTS: %d", pi->sync_pts);
-        } else {
-            indent_printf(level+1, "%s.m2ts", pi->clip[0].clip_id);
-        }
-    }
-}
-
-static void
-_show_pip_metadata_block(MPLS_PIP_METADATA *block, int level)
-{
-    int ii;
-
-    indent_printf(level, "Clip ref: %d", block->clip_ref);
-    indent_printf(level, "Secondary video ref: %d", block->secondary_video_ref);
-    indent_printf(level, "Timeline type: %d", block->timeline_type);
-    indent_printf(level, "Luma key flag: %d", block->luma_key_flag);
-    if (block->luma_key_flag) {
-        indent_printf(level, "Upper limit luma key: %d", block->upper_limit_luma_key);
-    }
-    indent_printf(level, "Trick play flag: %d", block->trick_play_flag);
-
-    for (ii = 0; ii < block->data_count; ii++) {
-        indent_printf(level, "data block %d:", ii);
-        indent_printf(level+1, "Timestamp: %d", block->data[ii].time);
-        indent_printf(level+1, "Horizontal position %d", block->data[ii].xpos);
-        indent_printf(level+1, "Vertical position: %d", block->data[ii].ypos);
-        indent_printf(level+1, "Scaling factor: %d", block->data[ii].scale_factor);
-    }
-}
-
-static void
-_show_pip_metadata(MPLS_PL *pl, int level)
-{
-    int ii;
-
-    for (ii = 0; ii < pl->ext_pip_data_count; ii++) {
-        MPLS_PIP_METADATA *data;
-
-        data = &pl->ext_pip_data[ii];
-
-        indent_printf(level, "PiP metadata block %d:", ii);
-        _show_pip_metadata_block(data, level+1);
-    }
-}
-
-static void
-_show_sub_paths(MPLS_PL *pl, int level)
-{
-    int ss;
-
-    for (ss = 0; ss < pl->sub_count; ss++) {
-        MPLS_SUB *sub;
-
-        sub = &pl->sub_path[ss];
-
-        indent_printf(level, "Sub Path %d:", ss);
-        _show_sub_path(sub, level+1);
-    }
-}
-
-static void
-_show_sub_paths_ss(MPLS_PL *pl, int level)
-{
-    int ss;
-
-    for (ss = 0; ss < pl->ext_sub_count; ss++) {
-        MPLS_SUB *sub;
-
-        sub = &pl->ext_sub_path[ss];
-
-        indent_printf(level, "Extension Sub Path %d:", ss);
-        _show_sub_path(sub, level+1);
-    }
-}
-
-static uint32_t
-_pl_duration(MPLS_PL *pl)
-{
-    int ii;
-    uint32_t duration = 0;
-    MPLS_PI *pi;
-
-    for (ii = 0; ii < pl->list_count; ii++) {
-        pi = &pl->play_item[ii];
-        duration += pi->out_time - pi->in_time;
-    }
-    return duration;
-}
-
-static int
-_filter_dup(MPLS_PL *pl_list[], int count, MPLS_PL *pl)
-{
-    int ii, jj;
-
-    for (ii = 0; ii < count; ii++) {
-        if (pl->list_count != pl_list[ii]->list_count ||
-            _pl_duration(pl) != _pl_duration(pl_list[ii])) {
-            continue;
-        }
-        for (jj = 0; jj < pl->list_count; jj++) {
-            MPLS_PI *pi1, *pi2;
-
-            pi1 = &pl->play_item[jj];
-            pi2 = &pl_list[ii]->play_item[jj];
-
-            if (memcmp(pi1->clip[0].clip_id, pi2->clip[0].clip_id, 5) != 0 ||
-                pi1->in_time != pi2->in_time ||
-                pi1->out_time != pi2->out_time) {
-                break;
-            }
-        }
-        if (jj != pl->list_count) {
-            continue;
-        }
-        return 0;
-    }
-    return 1;
-}
-
-static int
-_find_repeats(MPLS_PL *pl, const char *m2ts)
-{
-    int ii, count = 0;
-
-    for (ii = 0; ii < pl->list_count; ii++) {
-        MPLS_PI *pi;
-
-        pi = &pl->play_item[ii];
-        // Ignore titles with repeated segments
-        if (strcmp(pi->clip[0].clip_id, m2ts) == 0) {
-            count++;
-        }
-    }
-    return count;
-}
-
-static int
-_filter_short(MPLS_PL *pl, unsigned int seconds)
-{
-    // Ignore short playlists
-    if (_pl_duration(pl) / 45000 <= seconds) {
-        return 0;
-    }
-    return 1;
-}
-
-static int
-_filter_repeats(MPLS_PL *pl, int repeats)
-{
-    int ii;
-
-    for (ii = 0; ii < pl->list_count; ii++) {
-        MPLS_PI *pi;
-
-        pi = &pl->play_item[ii];
-        // Ignore titles with repeated segments
-        if (_find_repeats(pl, pi->clip[0].clip_id) > repeats) {
-            return 0;
-        }
-    }
-    return 1;
-}
-
-static int clip_list = 0, playlist_info = 0, chapter_marks = 0, sub_paths = 0, pip_metadata = 0;
-static int repeats = 0, seconds = 0, dups = 0;
-
-static MPLS_PL*
-_process_file(char *name, MPLS_PL *pl_list[], int pl_count)
-{
-    MPLS_PL *pl;
-
-    pl = bd_read_mpls(name);
-    if (pl == NULL) {
-        fprintf(stderr, "Parse failed: %s\n", name);
-        return NULL;
-    }
-    if (seconds) {
-        if (!_filter_short(pl, seconds)) {
-            bd_free_mpls(pl);
-            return NULL;
-        }
-    }
-    if (repeats) {
-        if (!_filter_repeats(pl, repeats)) {
-            bd_free_mpls(pl);
-            return NULL;
-        }
-    }
-    if (dups) {
-        if (!_filter_dup(pl_list, pl_count, pl)) {
-            bd_free_mpls(pl);
-            return NULL;
-        }
-    }
-    if (verbose) {
-        indent_printf(0, 
-                    "%s -- Num Clips: %3d , Duration: minutes %4u:%02u",
-                    basename(name),
-                    pl->list_count,
-                    _pl_duration(pl) / (45000 * 60),
-                    (_pl_duration(pl) / 45000) % 60);
-        _show_ai(pl, 1);
-    } else {
-        indent_printf(0, "%s -- Duration: minutes %4u:%02u",
-                    basename(name),
-                    _pl_duration(pl) / (45000 * 60),
-                    (_pl_duration(pl) / 45000) % 60);
-    }
-    if (playlist_info) {
-        _show_details(pl, 1);
-    }
-    if (chapter_marks) {
-        _show_marks(pl, 1);
-    }
-    if (pip_metadata) {
-        _show_pip_metadata(pl, 1);
-    }
-    if (clip_list) {
-        _show_clip_list(pl, 1);
-    }
-    if (sub_paths) {
-        _show_sub_paths(pl, 1);
-        _show_sub_paths_ss(pl, 1);
-    }
-    return pl;
-}
-
-static void
-_usage(char *cmd)
-{
-    fprintf(stderr, 
-"Usage: %s -vli <mpls file> [<mpls file> ...]\n"
-"With no options, produces a list of the playlist(s) with durations\n"
-"Options:\n"
-"    v             - Verbose output.\n"
-"    l             - Produces a list of the m2ts clips\n"
-"    i             - Dumps detailed information about each clip\n"
-"    c             - Show chapter marks\n"
-"    p             - Show sub paths\n"
-"    P             - Show picture-in-picture metadata\n"
-"    r <N>         - Filter out titles that have >N repeating clips\n"
-"    d             - Filter out duplicate titles\n"
-"    s <seconds>   - Filter out short titles\n"
-"    f             - Filter combination -r2 -d -s900\n"
-, cmd);
-
-    exit(EXIT_FAILURE);
-}
-
-#define OPTS "vlicpPfr:ds:"
-
-static int
-_qsort_str_cmp(const void *a, const void *b)
-{
-    const char *stra = *(char * const *)a;
-    const char *strb = *(char * const *)b;
-
-    return strcmp(stra, strb);
-}
-
-int
-main(int argc, char *argv[])
-{
-    MPLS_PL *pl;
-    int opt;
-    int ii, pl_ii;
-    MPLS_PL *pl_list[1000];
-    struct stat st;
-    char *path = NULL;
-    DIR *dir = NULL;
-
-    do {
-        opt = getopt(argc, argv, OPTS);
-        switch (opt) {
-            case -1: 
-                break;
-
-            case 'v':
-                verbose = 1;
-                break;
-
-            case 'l':
-                clip_list = 1;
-                break;
-
-            case 'i':
-                playlist_info = 1;
-                break;
-
-            case 'c':
-                chapter_marks = 1;
-                break;
-
-            case 'p':
-                sub_paths = 1;
-                break;
-
-            case 'P':
-                pip_metadata = 1;
-                break;
-
-            case 'd':
-                dups = 1;
-                break;
-
-            case 'r':
-                repeats = atoi(optarg);
-                break;
-
-            case 'f':
-                repeats = 2;
-                dups = 1;
-                seconds = 900;
-                break;
-
-            case 's':
-                seconds = atoi(optarg);
-                break;
-
-            default:
-                _usage(argv[0]);
-                break;
-        }
-    } while (opt != -1);
-
-    if (optind >= argc) {
-        _usage(argv[0]);
-    }
-
-    for (pl_ii = 0, ii = optind; pl_ii < 1000 && ii < argc; ii++) {
-
-        if (stat(argv[ii], &st)) {
-            continue;
-        }
-        dir = NULL;
-        if (S_ISDIR(st.st_mode)) {
-
-            printf("Directory: %s:\n", argv[ii]);
-            path = _mk_path(argv[ii], PLAYLIST_DIR);
-            if (path == NULL) {
-                fprintf(stderr, "Failed to find playlist path: %s\n", argv[ii]);
-                continue;
-            }
-            dir = opendir(path);
-            if (dir == NULL) {
-                fprintf(stderr, "Failed to open dir: %s\n", path);
-                free(path);
-                continue;
-            }
-        }
-        if (dir != NULL) {
-            char **dirlist = (char**)calloc(10001, sizeof(char*));
-            struct dirent *ent;
-            int jj = 0;
-            for (ent = readdir(dir); ent != NULL; ent = readdir(dir)) {
-                dirlist[jj++] = strcpy((char*)malloc(strlen(ent->d_name)), ent->d_name);
-            }
-            qsort(dirlist, jj, sizeof(char*), _qsort_str_cmp);
-            for (jj = 0; dirlist[jj] != NULL; jj++) {
-                char *name = NULL;
-                name = _mk_path(path, dirlist[jj]);
-                free(dirlist[jj]);
-                if (stat(name, &st)) {
-                    free(name);
-                    continue;
-                }
-                if (!S_ISREG(st.st_mode)) {
-                    free(name);
-                    continue;
-                }
-                pl = _process_file(name, pl_list, pl_ii);
-                free(name);
-                if (pl != NULL) {
-                    pl_list[pl_ii++] = pl;
-                }
-            }
-            free(dirlist);
-            free(path);
-        } else {
-            pl = _process_file(argv[ii], pl_list, pl_ii);
-            if (pl != NULL) {
-                pl_list[pl_ii++] = pl;
-            }
-        }
-    }
-    // Cleanup
-    for (ii = 0; ii < pl_ii; ii++) {
-        bd_free_mpls(pl_list[ii]);
-    }
-    return 0;
-}
-
diff --git a/src/examples/util.c b/src/examples/util.c
deleted file mode 100644
index aaa4c46..0000000
--- a/src/examples/util.c
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * This file is part of libbluray
- * Copyright (C) 2009-2010  John Stebbins
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-#include <stdarg.h>
-
-#include "util.h"
-
-void
-indent_printf(int level, const char *fmt, ...)
-{
-    va_list ap;
-    int ii;
-
-    for (ii = 0; ii < level; ii++)
-    {
-        printf("    ");
-    }
-    va_start(ap, fmt);
-    vprintf(fmt, ap);
-    va_end(ap);
-    printf("\n");
-}
-
diff --git a/src/examples/util.h b/src/examples/util.h
deleted file mode 100644
index 144f8ec..0000000
--- a/src/examples/util.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * This file is part of libbluray
- * Copyright (C) 2009-2010  John Stebbins
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#include <stdint.h>
-
-#include "util/attributes.h"
-
-#if defined( __MINGW32__ )
-#   undef  lseek
-#   define lseek  _lseeki64
-#   undef  fseeko
-#   define fseeko fseeko64
-#   undef  ftello
-#   define ftello ftello64
-#   define flockfile(...)
-#   define funlockfile(...)
-#   define getc_unlocked getc
-#   undef  off_t
-#   define off_t off64_t
-#   undef  stat
-#   define stat  _stati64
-#   define fstat _fstati64
-#   define wstat _wstati64
-#endif
-
-void indent_printf(int level, const char *fmt, ...) BD_ATTR_FORMAT_PRINTF(2,3);
-
diff --git a/src/file/dir_win32.c b/src/file/dir_win32.c
index 2690658..f42114d 100644
--- a/src/file/dir_win32.c
+++ b/src/file/dir_win32.c
@@ -86,8 +86,8 @@ static BD_DIR_H *_dir_open_win32(const char* dirname)
 
     dir->internal = priv;
 
-    wchar_t wfilespec[MAX_PATH];
-    if (MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, filespec, -1, wfilespec, MAX_PATH))
+    wchar_t wfilespec[4096 + 1] = {0};
+    if (MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, filespec, -1, wfilespec, 4096))
         priv->handle = _wfindfirst(wfilespec, &priv->info);
     else
         priv->handle = -1;
diff --git a/src/file/dirs_win32.c b/src/file/dirs_win32.c
index e165fea..3d07251 100644
--- a/src/file/dirs_win32.c
+++ b/src/file/dirs_win32.c
@@ -36,7 +36,7 @@
 
 char *win32_get_font_dir(const char *font_file)
 {
-    wchar_t wdir[MAX_PATH];
+    wchar_t wdir[MAX_PATH+1] = {0};
     if (S_OK != SHGetFolderPathW(NULL, CSIDL_FONTS, NULL, SHGFP_TYPE_CURRENT, wdir)) {
         int lenght = GetWindowsDirectoryW(wdir, MAX_PATH);
         if (lenght == 0 || lenght > (MAX_PATH - 8)) {
@@ -67,7 +67,7 @@ char *file_get_config_home(void)
 
 char *file_get_data_home(void)
 {
-    wchar_t wdir[MAX_PATH];
+    wchar_t wdir[MAX_PATH+1] = {0};
 
     /* Get the "Application Data" folder for the user */
     if (S_OK == SHGetFolderPathW(NULL, CSIDL_APPDATA | CSIDL_FLAG_CREATE,
@@ -92,7 +92,7 @@ char *file_get_cache_home(void)
 const char *file_get_config_system(const char *dir)
 {
     static char *appdir = NULL;
-    wchar_t wdir[MAX_PATH];
+    wchar_t wdir[MAX_PATH+1] = {0};
 
     if (!dir) {
         // first call
diff --git a/src/file/dl_win32.c b/src/file/dl_win32.c
index e4492e1..7f6ae73 100644
--- a/src/file/dl_win32.c
+++ b/src/file/dl_win32.c
@@ -57,7 +57,7 @@ void *dl_dlopen(const char *path, const char *version)
 {
     (void)version;
 
-    wchar_t wname[MAX_PATH];
+    wchar_t wname[MAX_PATH+1] = {0};
     char *name;
     void *result;
 
@@ -109,7 +109,7 @@ const char *dl_get_path(void)
     if (!initialized) {
         initialized = 1;
 
-        static char path[MAX_PATH];
+        static char path[MAX_PATH + 1];
         HMODULE hModule;
         wchar_t wpath[MAX_PATH];
 
diff --git a/src/file/file_win32.c b/src/file/file_win32.c
index 5eb52d7..c0f48e4 100644
--- a/src/file/file_win32.c
+++ b/src/file/file_win32.c
@@ -97,9 +97,9 @@ static BD_FILE_H *_file_open(const char* filename, const char *mode)
 {
     BD_FILE_H *file;
     FILE *fp;
-    wchar_t wfilename[MAX_PATH], wmode[8];
+    wchar_t wfilename[4096 + 1] = {0}, wmode[8] = {0};
 
-    if (!MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, filename, -1, wfilename, MAX_PATH) ||
+    if (!MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, filename, -1, wfilename, 4096) ||
         !MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, mode, -1, wmode, 8)) {
 
         BD_DEBUG(DBG_FILE, "Error opening file %s\n", filename);
@@ -112,6 +112,9 @@ static BD_FILE_H *_file_open(const char* filename, const char *mode)
         return NULL;
     }
 
+    // Set file buffer
+    setvbuf(fp, NULL, _IOFBF, 6144 * 10);
+
     file = calloc(1, sizeof(BD_FILE_H));
     if (!file) {
         BD_DEBUG(DBG_FILE | DBG_CRIT, "Error opening file %s (out of memory)\n", filename);
diff --git a/src/libbluray/bdj/java-j2se/java/awt/BDGraphics.java b/src/libbluray/bdj/java-j2se/java/awt/BDGraphics.java
index 54c24e5..77ce66e 100644
--- a/src/libbluray/bdj/java-j2se/java/awt/BDGraphics.java
+++ b/src/libbluray/bdj/java-j2se/java/awt/BDGraphics.java
@@ -53,6 +53,7 @@ class BDGraphics extends BDGraphicsBase {
 
     public java.awt.font.FontRenderContext getFontRenderContext()
     {
+        logger.unimplemented("getFontRenderContext");
         return null;
     }
     public void setPaint(Paint p) {
diff --git a/src/libbluray/bdj/java/java/awt/BDToolkitBase.java b/src/libbluray/bdj/java/java/awt/BDToolkitBase.java
index dc61bef..0f5e3e0 100644
--- a/src/libbluray/bdj/java/java/awt/BDToolkitBase.java
+++ b/src/libbluray/bdj/java/java/awt/BDToolkitBase.java
@@ -124,6 +124,10 @@ abstract class BDToolkitBase extends Toolkit {
     }
 
     public Image getImage(String filename) {
+        if (BDJXletContext.getCurrentContext() == null) {
+            logger.error("getImage(): no context " + Logger.dumpStack());
+        }
+
         if (cachedImages.containsKey(filename))
             return (Image)cachedImages.get(filename);
         Image newImage = createImage(filename);
@@ -133,6 +137,10 @@ abstract class BDToolkitBase extends Toolkit {
     }
 
     public Image getImage(URL url) {
+        if (BDJXletContext.getCurrentContext() == null) {
+            logger.error("getImage(): no context " + Logger.dumpStack());
+        }
+
         if (cachedImages.containsKey(url))
             return (Image)cachedImages.get(url);
         Image newImage = createImage(url);
@@ -142,6 +150,10 @@ abstract class BDToolkitBase extends Toolkit {
     }
 
     public Image createImage(String filename) {
+        if (BDJXletContext.getCurrentContext() == null) {
+            logger.error("createImage(): no context " + Logger.dumpStack());
+        }
+
         if (!new File(filename).isAbsolute()) {
             String home = BDJXletContext.getCurrentXletHome();
             if (home != null) {
@@ -161,6 +173,9 @@ abstract class BDToolkitBase extends Toolkit {
     }
 
     public Image createImage(URL url) {
+        if (BDJXletContext.getCurrentContext() == null) {
+            logger.error("createImage(): no context " + Logger.dumpStack());
+        }
         ImageProducer ip = new URLImageSource(url);
         Image newImage = createImage(ip);
         return newImage;
@@ -169,12 +184,20 @@ abstract class BDToolkitBase extends Toolkit {
     public Image createImage(byte[] imagedata,
         int imageoffset,
         int imagelength) {
+
+        if (BDJXletContext.getCurrentContext() == null) {
+            logger.error("createImage(): no context " + Logger.dumpStack());
+        }
+
         ImageProducer ip = new ByteArrayImageSource(imagedata, imageoffset, imagelength);
         Image newImage = createImage(ip);
         return newImage;
     }
 
     public Image createImage(ImageProducer producer) {
+        if (BDJXletContext.getCurrentContext() == null) {
+            logger.error("createImage(): no context " + Logger.dumpStack());
+        }
         return new BDImageConsumer(producer);
     }
 
diff --git a/src/libbluray/bdj/java/javax/media/MediaLocator.java b/src/libbluray/bdj/java/javax/media/MediaLocator.java
index a182e8d..245ac54 100644
--- a/src/libbluray/bdj/java/javax/media/MediaLocator.java
+++ b/src/libbluray/bdj/java/javax/media/MediaLocator.java
@@ -25,11 +25,11 @@ import java.net.URL;
 
 public class MediaLocator implements Serializable
 {
-    public MediaLocator(URL url) { 
+    public MediaLocator(URL url) {
         this(url.toExternalForm());
     }
 
-    public MediaLocator(String locatorString) { 
+    public MediaLocator(String locatorString) {
         int index = locatorString.indexOf(":");
         if (index <= 0)
             throw new IllegalArgumentException("Bad locator string.");
@@ -56,7 +56,7 @@ public class MediaLocator implements Serializable
     public String toExternalForm() {
         return protocol + ":" + remainder;
     }
-    
+
     private String protocol = "";
     private String remainder = "";
 
diff --git a/src/libbluray/bdj/java/javax/tv/locator/LocatorImpl.java b/src/libbluray/bdj/java/javax/tv/locator/LocatorImpl.java
index e14825c..a87269a 100644
--- a/src/libbluray/bdj/java/javax/tv/locator/LocatorImpl.java
+++ b/src/libbluray/bdj/java/javax/tv/locator/LocatorImpl.java
@@ -24,7 +24,7 @@ public class LocatorImpl implements Locator {
         this.url = url;
     }
 
-    public boolean hasMultipleTransformations()    {
+    public boolean hasMultipleTransformations() {
         return false;
     }
 
diff --git a/src/libbluray/bdj/java/org/videolan/BDJLoader.java b/src/libbluray/bdj/java/org/videolan/BDJLoader.java
index 59410c5..b2bcff3 100644
--- a/src/libbluray/bdj/java/org/videolan/BDJLoader.java
+++ b/src/libbluray/bdj/java/org/videolan/BDJLoader.java
@@ -185,11 +185,6 @@ public class BDJLoader {
                 throw new InvalidObjectException("bdjo not loaded");
             AppEntry[] appTable = bdjo.getAppTable();
 
-            // initialize AppCaches
-            if (vfsCache != null) {
-                vfsCache.add(bdjo.getAppCaches());
-            }
-
             // reuse appProxys
             BDJAppProxy[] proxys = new BDJAppProxy[appTable.length];
             AppsDatabase db = AppsDatabase.getAppsDatabase();
@@ -215,7 +210,6 @@ public class BDJLoader {
                             proxy.stop(true);
                         } else {
                             logger.info("Keeping xlet " + appTable[i].getInitialClass());
-                            proxy.getXletContext().update(appTable[i], bdjo.getAppCaches());
                             proxys[i] = proxy;
                             proxy = null;
                         }
@@ -240,6 +234,11 @@ public class BDJLoader {
             Libbluray.setUOMask(terminfo.getMenuCallMask(), terminfo.getTitleSearchMask());
             Libbluray.setKeyInterest(bdjo.getKeyInterestTable());
 
+            // initialize AppCaches
+            if (vfsCache != null) {
+                vfsCache.add(bdjo.getAppCaches());
+            }
+
             // initialize appProxys
             for (int i = 0; i < appTable.length; i++) {
                 if (proxys[i] == null) {
@@ -256,6 +255,7 @@ public class BDJLoader {
                     }
                     logger.info("Loaded class: " + appTable[i].getInitialClass() + p + " from " + appTable[i].getBasePath() + ".jar");
                 } else {
+                    proxys[i].getXletContext().update(appTable[i], bdjo.getAppCaches());
                     logger.info("Reused class: " + appTable[i].getInitialClass() +     " from " + appTable[i].getBasePath() + ".jar");
                 }
             }
@@ -266,6 +266,19 @@ public class BDJLoader {
             // notify AppsDatabase
             ((BDJAppsDatabase)BDJAppsDatabase.getAppsDatabase()).newDatabase(bdjo, proxys);
 
+            // auto start playlist
+            try {
+                PlayListTable plt = bdjo.getAccessiblePlaylists();
+                if ((plt != null) && (plt.isAutostartFirst())) {
+                    logger.info("Auto-starting playlist");
+                    String[] pl = plt.getPlayLists();
+                    if (pl.length > 0)
+                        Manager.createPlayer(new MediaLocator(new BDLocator("bd://PLAYLIST:" + pl[0]))).start();
+                }
+            } catch (Exception e) {
+                logger.error("loadN(): autoplaylist failed: " + e + "\n" + Logger.dumpStack(e));
+            }
+
             // now run all the xlets
             for (int i = 0; i < appTable.length; i++) {
                 int code = appTable[i].getControlCode();
@@ -282,15 +295,6 @@ public class BDJLoader {
 
             logger.info("Finished initializing and starting xlets.");
 
-            // auto start playlist
-            PlayListTable plt = bdjo.getAccessiblePlaylists();
-            if ((plt != null) && (plt.isAutostartFirst())) {
-                logger.info("Auto-starting playlist");
-                String[] pl = plt.getPlayLists();
-                if (pl.length > 0)
-                    Manager.createPlayer(new MediaLocator(new BDLocator("bd://PLAYLIST:" + pl[0]))).start();
-            }
-
             return true;
 
         } catch (Throwable e) {
diff --git a/src/libbluray/bdj/java/org/videolan/BDJXletContext.java b/src/libbluray/bdj/java/org/videolan/BDJXletContext.java
index 359cd28..8ee818a 100644
--- a/src/libbluray/bdj/java/org/videolan/BDJXletContext.java
+++ b/src/libbluray/bdj/java/org/videolan/BDJXletContext.java
@@ -70,7 +70,12 @@ public class BDJXletContext implements javax.tv.xlet.XletContext, javax.microedi
         try {
             int homeJarID = Integer.parseInt(home);
             long time = System.currentTimeMillis();
-            homeMountPoint = MountManager.mount(homeJarID, false) + java.io.File.separator;
+            homeMountPoint = MountManager.mount(homeJarID, false);
+            if (homeMountPoint == null) {
+                logger.error("Failed mounting " + home + ".jar");
+            } else {
+                homeMountPoint = homeMountPoint + java.io.File.separator;
+            }
             time = System.currentTimeMillis() - time;
             logger.info("Mounted Xlet home directory from " + home + ".jar " +
                         "to " + homeMountPoint + "(" + time + "ms)");
diff --git a/src/libbluray/bdj/java/org/videolan/IxcRegistryImpl.java b/src/libbluray/bdj/java/org/videolan/IxcRegistryImpl.java
index 144f1ab..bae986f 100644
--- a/src/libbluray/bdj/java/org/videolan/IxcRegistryImpl.java
+++ b/src/libbluray/bdj/java/org/videolan/IxcRegistryImpl.java
@@ -452,7 +452,7 @@ public class IxcRegistryImpl {
         }
         Object remoteObj = wrapOrCopy(wrappedObj, wrappedObj.context, (BDJXletContext)xc);
 
-        Debug("IxcRegistry.lookup(" + path + ") => " + remoteObj);
+        Debug("IxcRegistry.lookup(" + path + ") => OK");
 
         return (Remote)remoteObj;
     }
diff --git a/src/libbluray/bdj/java/org/videolan/MountManager.java b/src/libbluray/bdj/java/org/videolan/MountManager.java
index 5c9660a..6f6fd52 100644
--- a/src/libbluray/bdj/java/org/videolan/MountManager.java
+++ b/src/libbluray/bdj/java/org/videolan/MountManager.java
@@ -185,6 +185,7 @@ public class MountManager {
                 new PrivilegedAction() {
                     public Object run() {
                         if (mountPoint.decRefCount() < 1) {
+                            logger.error("Removing JAR " + id + " from mount cache");
                             mountPoints.remove(id);
                         }
                         return null;
diff --git a/src/libbluray/bdj/java/org/videolan/media/content/PlayerManager.java b/src/libbluray/bdj/java/org/videolan/media/content/PlayerManager.java
index cc06e84..d45358b 100644
--- a/src/libbluray/bdj/java/org/videolan/media/content/PlayerManager.java
+++ b/src/libbluray/bdj/java/org/videolan/media/content/PlayerManager.java
@@ -19,6 +19,7 @@
 package org.videolan.media.content;
 
 import java.util.ArrayList;
+import org.videolan.Logger;
 
 public class PlayerManager {
 
@@ -81,7 +82,7 @@ public class PlayerManager {
             return;
         }
 
-        System.err.println("unknown player type: " + player.getClass().getName());
+        logger.error("unknown player type: " + player.getClass().getName());
     }
 
     protected boolean allocateResource(BDHandler player) {
@@ -91,6 +92,9 @@ public class PlayerManager {
             }
             synchronized (playlistPlayerLock) {
                 if (playlistPlayer != null && player != playlistPlayer) {
+
+                    logger.info("allocateResource(): Stopping old playlist player");
+
                     playlistPlayer.stop();
                     playlistPlayer.deallocate();
                 }
@@ -108,7 +112,7 @@ public class PlayerManager {
             return true;
         }
 
-        System.err.println("unknown player type: " + player.getClass().getName());
+        logger.error("allocateResource(): unknown player type: " + player.getClass().getName());
         return false;
     }
 
@@ -153,4 +157,6 @@ public class PlayerManager {
         }
         }
     }
+
+    private static final Logger logger = Logger.getLogger(PlayerManager.class.getName());
 }
diff --git a/src/libbluray/bdnav/clpi_parse.c b/src/libbluray/bdnav/clpi_parse.c
index ec57a38..f0826de 100644
--- a/src/libbluray/bdnav/clpi_parse.c
+++ b/src/libbluray/bdnav/clpi_parse.c
@@ -39,6 +39,7 @@
 #define CLPI_SIG1  ('H' << 24 | 'D' << 16 | 'M' << 8 | 'V')
 #define CLPI_SIG2A ('0' << 24 | '2' << 16 | '0' << 8 | '0')
 #define CLPI_SIG2B ('0' << 24 | '1' << 16 | '0' << 8 | '0')
+#define CLPI_SIG2C ('0' << 24 | '2' << 16 | '4' << 8 | '0')
 
 static void
 _human_readable_sig(char *sig, uint32_t s1, uint32_t s2)
@@ -129,7 +130,8 @@ _parse_header(BITSTREAM *bits, CLPI_CL *cl)
     cl->type_indicator2 = bs_read(bits, 32);
     if (cl->type_indicator != CLPI_SIG1 || 
         (cl->type_indicator2 != CLPI_SIG2A &&
-         cl->type_indicator2 != CLPI_SIG2B)) {
+         cl->type_indicator2 != CLPI_SIG2B &&
+         cl->type_indicator2 != CLPI_SIG2C)) {
 
         char sig[9];
         char expect[9];
diff --git a/src/libbluray/bdnav/mpls_parse.c b/src/libbluray/bdnav/mpls_parse.c
index da01f7b..8bfbb8c 100644
--- a/src/libbluray/bdnav/mpls_parse.c
+++ b/src/libbluray/bdnav/mpls_parse.c
@@ -39,6 +39,7 @@
 #define MPLS_SIG1  ('M' << 24 | 'P' << 16 | 'L' << 8 | 'S')
 #define MPLS_SIG2A ('0' << 24 | '2' << 16 | '0' << 8 | '0')
 #define MPLS_SIG2B ('0' << 24 | '1' << 16 | '0' << 8 | '0')
+#define MPLS_SIG2C ('0' << 24 | '2' << 16 | '4' << 8 | '0')
 
 static void
 _human_readable_sig(char *sig, uint32_t s1, uint32_t s2)
@@ -137,8 +138,9 @@ _parse_appinfo(BITSTREAM *bits, MPLS_AI *ai)
     ai->random_access_flag = bs_read(bits, 1);
     ai->audio_mix_flag = bs_read(bits, 1);
     ai->lossless_bypass_flag = bs_read(bits, 1);
+    ai->mvc_base_view_r_flag = bs_read(bits, 1);
     // Reserved
-    bs_skip(bits, 13);
+    bs_skip(bits, 12);
     bs_seek_byte(bits, pos + len);
     return 1;
 }
@@ -155,7 +157,8 @@ _parse_header(BITSTREAM *bits, MPLS_PL *pl)
     pl->type_indicator2 = bs_read(bits, 32);
     if (pl->type_indicator != MPLS_SIG1 || 
         (pl->type_indicator2 != MPLS_SIG2A && 
-         pl->type_indicator2 != MPLS_SIG2B)) {
+         pl->type_indicator2 != MPLS_SIG2B &&
+         pl->type_indicator2 != MPLS_SIG2C)) {
 
         char sig[9];
         char expect[9];
@@ -259,6 +262,7 @@ _parse_stream(BITSTREAM *bits, MPLS_STREAM *s)
             break;
     };
     s->lang[3] = '\0';
+    s->ss_offset_sequence_id = 0xFF;
 
     bs_seek_byte(bits, pos + len);
     return 1;
@@ -882,6 +886,99 @@ _parse_subpath_extension(BITSTREAM *bits, MPLS_PL *pl)
 }
 
 static int
+_parse_stn_ss_extension(BITSTREAM *bits, MPLS_PL *pl)
+{
+    int ii, s;
+    int64_t pos;
+
+    for (ii = 0; ii < pl->list_count; ii++) {
+        uint32_t len = bs_read(bits, 16);
+        pos = bs_pos(bits) >> 3;
+        int Fixed_offset_during_PopUp_flag = bs_read(bits, 1);
+        bs_skip(bits, 15); // reserved
+
+        for (s = 0; s < pl->play_item[ii].stn.num_video; s++) {
+            // stream_entry
+            uint32_t slen = bs_read(bits, 8);
+            bs_skip(bits, slen * 8);
+
+            // stream_attributes_ss
+            slen = bs_read(bits, 8);
+            bs_skip(bits, slen * 8);
+
+            bs_skip(bits, 10); // reserved
+            bs_skip(bits, 6);  // number_of_offset_sequences
+        }
+
+        for (s = 0; s < pl->play_item[ii].stn.num_pg; s++) {
+            pl->play_item[ii].stn.pg[s].ss_offset_sequence_id = bs_read(bits, 8);
+
+            bs_skip(bits, 4); // reserved
+            bs_skip(bits, 1); // dialog_region_offset_valid_flag
+            int is_SS_PG = bs_read(bits, 1);
+            int is_top_AS_PG_textST = bs_read(bits, 1);
+            int is_bottom_AS_PG_textST = bs_read(bits, 1);
+            if (is_SS_PG) {
+                // stream_entry left eye
+                uint32_t slen = bs_read(bits, 8);
+                bs_skip(bits, slen * 8);
+
+                // stream_entry right eye
+                slen = bs_read(bits, 8);
+                bs_skip(bits, slen * 8);
+
+                bs_skip(bits, 8); // reserved
+                bs_skip(bits, 8); // PG offset
+            }
+            if (is_top_AS_PG_textST) {
+                // stream_entry
+                uint32_t slen = bs_read(bits, 8);
+                bs_skip(bits, slen * 8);
+
+                bs_skip(bits, 8); // reserved
+                bs_skip(bits, 8); // PG offset
+            }
+            if (is_bottom_AS_PG_textST) {
+                // stream_entry
+                uint32_t slen = bs_read(bits, 8);
+                bs_skip(bits, slen * 8);
+
+                bs_skip(bits, 8); // reserved
+                bs_skip(bits, 8); // PG offset
+            }
+        }
+
+        for (s = 0; s < pl->play_item[ii].stn.num_ig; s++) {
+            if (Fixed_offset_during_PopUp_flag)
+              bs_skip(bits, 8);
+            else
+              pl->play_item[ii].stn.ig[s].ss_offset_sequence_id = bs_read(bits, 8);
+
+            bs_skip(bits, 16); // IG_Plane_offset_during_BB_video
+            bs_skip(bits, 7); // reserved
+            int is_SS_IG = bs_read(bits, 1);
+            if (is_SS_IG) {
+                // stream_entry left eye
+                uint32_t slen = bs_read(bits, 8);
+                bs_skip(bits, slen * 8);
+
+                // stream_entry right eye
+                slen = bs_read(bits, 8);
+                bs_skip(bits, slen * 8);
+
+                bs_skip(bits, 8); // reserved
+                bs_skip(bits, 8); // PG offset
+            }
+        }
+
+        // Skip to next play item
+        bs_seek_byte(bits, pos + len);
+    }
+
+    return 0;
+}
+
+static int
 _parse_mpls_extension(BITSTREAM *bits, int id1, int id2, void *handle)
 {
     MPLS_PL *pl = (MPLS_PL*)handle;
@@ -895,7 +992,7 @@ _parse_mpls_extension(BITSTREAM *bits, int id1, int id2, void *handle)
 
     if (id1 == 2) {
         if (id2 == 1) {
-            return 0;
+            return _parse_stn_ss_extension(bits, pl);
         }
         if (id2 == 2) {
             // SubPath entries extension
diff --git a/src/libbluray/bdnav/mpls_parse.h b/src/libbluray/bdnav/mpls_parse.h
index f9f7a18..94add53 100644
--- a/src/libbluray/bdnav/mpls_parse.h
+++ b/src/libbluray/bdnav/mpls_parse.h
@@ -49,6 +49,7 @@ typedef struct
     uint8_t         sv_num_pip_pg_ref;
     uint8_t        *sv_secondary_audio_ref;
     uint8_t        *sv_pip_pg_ref;
+    uint8_t         ss_offset_sequence_id;
 } MPLS_STREAM;
 
 typedef struct
@@ -110,6 +111,7 @@ typedef struct
     uint8_t         random_access_flag;
     uint8_t         audio_mix_flag;
     uint8_t         lossless_bypass_flag;
+    uint8_t         mvc_base_view_r_flag;
 } MPLS_AI;
 
 typedef struct
diff --git a/src/libbluray/bdnav/navigation.c b/src/libbluray/bdnav/navigation.c
index 39be4b7..cfd7739 100644
--- a/src/libbluray/bdnav/navigation.c
+++ b/src/libbluray/bdnav/navigation.c
@@ -174,6 +174,21 @@ _pl_duration(MPLS_PL *pl)
     return duration;
 }
 
+static uint32_t
+_pl_chapter_count(MPLS_PL *pl)
+{
+    unsigned ii, chapters = 0;
+
+    // Count the number of "entry" marks (skipping "link" marks)
+    // This is the the number of chapters
+    for (ii = 0; ii < pl->mark_count; ii++) {
+        if (pl->play_mark[ii].mark_type == BD_MARK_ENTRY) {
+            chapters++;
+        }
+    }
+    return chapters;
+}
+
 NAV_TITLE_LIST* nav_get_title_list(BD_DISC *disc, uint32_t flags, uint32_t min_title_length)
 {
     BD_DIR_H *dir;
@@ -446,7 +461,7 @@ static void _fill_clip(NAV_TITLE *title,
 NAV_TITLE* nav_title_open(BD_DISC *disc, const char *playlist, unsigned angle)
 {
     NAV_TITLE *title = NULL;
-    unsigned ii, ss, chapters = 0;
+    unsigned ii, ss;
     uint32_t pos = 0;
     uint32_t time = 0;
 
@@ -506,15 +521,8 @@ NAV_TITLE* nav_title_open(BD_DISC *disc, const char *playlist, unsigned angle)
         }
     }
 
-    // Count the number of "entry" marks (skipping "link" marks)
-    // This is the the number of chapters
-    for (ii = 0; ii < title->pl->mark_count; ii++) {
-        if (title->pl->play_mark[ii].mark_type == BD_MARK_ENTRY) {
-            chapters++;
-        }
-    }
-    title->chap_list.count = chapters;
-    title->chap_list.mark = calloc(chapters, sizeof(NAV_MARK));
+    title->chap_list.count = _pl_chapter_count(title->pl);
+    title->chap_list.mark = calloc(title->chap_list.count, sizeof(NAV_MARK));
     title->mark_list.count = title->pl->mark_count;
     title->mark_list.mark = calloc(title->pl->mark_count, sizeof(NAV_MARK));
 
diff --git a/src/libbluray/bdnav/sound_parse.c b/src/libbluray/bdnav/sound_parse.c
index b5d11fd..7c267da 100644
--- a/src/libbluray/bdnav/sound_parse.c
+++ b/src/libbluray/bdnav/sound_parse.c
@@ -169,7 +169,7 @@ static SOUND_DATA *_sound_parse(BD_FILE_H *fp)
 
     data_offsets = calloc(num_sounds, sizeof(uint32_t));
     data = calloc(1, sizeof(SOUND_DATA));
-    if (!data_offsets | !data) {
+    if (!data_offsets || !data) {
         BD_DEBUG(DBG_CRIT, "out of memory\n");
         goto error;
     }
diff --git a/src/libbluray/bluray.c b/src/libbluray/bluray.c
index 1aedf2c..27beed7 100644
--- a/src/libbluray/bluray.c
+++ b/src/libbluray/bluray.c
@@ -952,6 +952,7 @@ static void _fill_disc_info(BLURAY *bd, BD_ENC_INFO *enc_info)
     bd->disc_info.bdplus_handled     = enc_info->bdplus_handled;
     bd->disc_info.bdplus_gen         = enc_info->bdplus_gen;
     bd->disc_info.bdplus_date        = enc_info->bdplus_date;
+    bd->disc_info.no_menu_support    = enc_info->no_menu_support;
 
     bd->disc_info.udf_volume_id      = disc_volume_id(bd->disc);
 
@@ -1098,6 +1099,10 @@ static void _fill_disc_info(BLURAY *bd, BD_ENC_INFO *enc_info)
         indx_free(&index);
     }
 
+    if (!bd->disc_info.first_play_supported || !bd->disc_info.top_menu_supported) {
+        bd->disc_info.no_menu_support = 1;
+    }
+
     if (bd->disc_info.bdj_detected) {
         BDID_DATA *bdid = bdid_get(bd->disc); /* parse id.bdmv */
         if (bdid) {
@@ -1637,6 +1642,25 @@ int64_t bd_seek_time(BLURAY *bd, uint64_t tick)
     return bd->s_pos;
 }
 
+int64_t bd_find_seek_point(BLURAY *bd, uint64_t tick)
+{
+  uint32_t clip_pkt, out_pkt;
+  NAV_CLIP *clip;
+
+  tick /= 2;
+
+  if (bd->title &&
+    tick < bd->title->duration) {
+
+      // Find the closest access unit to the requested position
+      clip = nav_time_search(bd->title, (uint32_t)tick, &clip_pkt, &out_pkt);
+
+      return (int64_t)out_pkt * 192;
+  }
+
+  return bd->s_pos;
+}
+
 uint64_t bd_tell_time(BLURAY *bd)
 {
     uint32_t clip_pkt = 0, out_pkt = 0, out_time = 0;
@@ -2539,6 +2563,9 @@ uint32_t bd_get_titles(BLURAY *bd, uint8_t flags, uint32_t min_title_length)
 
 int bd_get_main_title(BLURAY *bd)
 {
+    if (!bd) {
+        return -1;
+    }
     if (bd->title_type != title_undef) {
         BD_DEBUG(DBG_CRIT | DBG_BLURAY, "bd_get_main_title() can't be used with BluRay menus\n");
     }
@@ -2606,6 +2633,7 @@ static BLURAY_TITLE_INFO* _fill_title_info(NAV_TITLE* title, uint32_t title_idx,
         BLURAY_CLIP_INFO *ci = &title_info->clips[ii];
         NAV_CLIP *nc = &title->clip_list.clip[ii];
 
+        ci->idx = nc->clip_id;
         ci->pkt_count = nc->end_pkt - nc->start_pkt;
         ci->start_time = (uint64_t)nc->title_time * 2;
         ci->in_time = (uint64_t)pi->in_time * 2;
@@ -2632,6 +2660,8 @@ static BLURAY_TITLE_INFO* _fill_title_info(NAV_TITLE* title, uint32_t title_idx,
         _copy_streams(nc, ci->sec_audio_streams, pi->stn.secondary_audio, ci->sec_audio_stream_count);
     }
 
+    title_info->mvc_base_view_r_flag = title->pl->app_info.mvc_base_view_r_flag;
+
     return title_info;
 }
 
@@ -2745,7 +2775,7 @@ int bd_set_player_setting(BLURAY *bd, uint32_t idx, uint32_t value)
     for (i = 0; i < sizeof(map) / sizeof(map[0]); i++) {
         if (idx == map[i].idx) {
             bd_mutex_lock(&bd->mutex);
-            result = !bd_psr_setting_write(bd->regs, idx, value);
+            result = !bd_psr_setting_write(bd->regs, map[i].psr, value);
             bd_mutex_unlock(&bd->mutex);
             return result;
         }
@@ -3119,6 +3149,11 @@ static int _play_title(BLURAY *bd, unsigned title)
         return 0;
     }
 
+    if (bd->disc_info.no_menu_support) {
+        BD_DEBUG(DBG_BLURAY | DBG_CRIT, "bd_play(): no menu support\n");
+        return 0;
+    }
+
     /* first play object ? */
     if (title == BLURAY_TITLE_FIRST_PLAY) {
 
@@ -3743,3 +3778,28 @@ void bd_free_bdjo(struct bdjo_data *obj)
     (void)obj;
 #endif
 }
+
+int bd_get_clip_infos(BLURAY *bd, unsigned clip, uint64_t *clip_start_time, uint64_t *stream_start_time, uint64_t *pos, uint64_t *duration)
+{
+    if (bd && bd->title && bd->title->clip_list.count > clip) {
+      if (clip_start_time)
+        *clip_start_time = (uint64_t)bd->title->clip_list.clip[clip].title_time << 1;
+      if (stream_start_time)
+        *stream_start_time = (uint64_t)bd->title->clip_list.clip[clip].in_time << 1;
+      if (pos)
+        *pos = (uint64_t)bd->title->clip_list.clip[clip].title_pkt * 192;
+      if (duration)
+        *duration = (uint64_t)bd->title->clip_list.clip[clip].duration << 1;
+
+      return 1;
+    }
+    return 0;
+}
+
+struct mpls_pl* bd_get_title_mpls(BLURAY * bd)
+{
+  if (bd && bd->title) {
+    return bd->title->pl;
+  }
+  return NULL;
+}
diff --git a/src/libbluray/bluray.h b/src/libbluray/bluray.h
index ae9f412..6e74df4 100644
--- a/src/libbluray/bluray.h
+++ b/src/libbluray/bluray.h
@@ -32,6 +32,7 @@ extern "C" {
  */
 
 #include <stdint.h>
+#include "bdnav/clpi_data.h"
 
 #define TITLES_ALL              0    /**< all titles. */
 #define TITLES_FILTER_DUP_TITLE 0x01 /**< remove duplicate titles. */
@@ -119,6 +120,9 @@ typedef struct {
     char bdj_disc_id[33];    /* (BD-J) disc ID */
 
     const char *udf_volume_id; /* optional UDF volume identifier */
+
+    uint8_t no_menu_support;   /* 1 if this disc can't be played using on-disc menus */
+
 } BLURAY_DISC_INFO;
 
 /*
@@ -216,6 +220,7 @@ typedef struct bd_stream_info {
 } BLURAY_STREAM_INFO;
 
 typedef struct bd_clip {
+    uint32_t           idx;
     uint32_t           pkt_count;
     uint8_t            still_mode;
     uint16_t           still_time;  /* seconds */
@@ -266,6 +271,8 @@ typedef struct bd_title_info {
 
     uint32_t             mark_count;
     BLURAY_TITLE_MARK    *marks;
+
+    uint8_t              mvc_base_view_r_flag;
 } BLURAY_TITLE_INFO;
 
 /*
@@ -458,6 +465,16 @@ uint32_t bd_get_current_title(BLURAY *bd);
 
 /**
  *
+ * Find the byte position to specific time in 90Khz ticks
+ *
+ * @param bd    BLURAY ojbect
+ * @param tick  tick count
+ * @return byte position
+ */
+int64_t bd_find_seek_point(BLURAY *bd, uint64_t tick);
+
+/**
+ *
  *  Read from currently selected title file, decrypt if possible
  *
  * @param bd  BLURAY object
@@ -981,7 +998,6 @@ int bd_mouse_select(BLURAY *bd, int64_t pts, uint16_t x, uint16_t y);
 
 /* access to internal information */
 
-struct clpi_cl;
 /**
  *
  *  Get copy of clip information for requested playitem.
@@ -1034,6 +1050,28 @@ void bd_stop_bdj(BLURAY *bd); // shutdown BD-J and clean up resources
  */
 int bd_read_file(BLURAY *, const char *path, void **data, int64_t *size);
 
+/**
+ *
+ * Get information about the clip
+ *
+ * @param bd  BLURAY object
+ * @param clip clip index
+ * @param clip_start_time start of the clip (in the total title) (in 90khz)
+ * @param stream_start_time first pts in the clip (in 90khz)
+ * @param byte position of the clip (absolute)
+ * @param duration duration of the clip (in 90khz)
+ */
+int bd_get_clip_infos(BLURAY *bd, unsigned clip, uint64_t *clip_start_time, uint64_t *stream_start_time, uint64_t *pos, uint64_t *duration);
+
+/**
+ * Get the MPLS struct of the current title
+ *
+ * @param bd BLURAY object
+ * @return the MPLS struct
+ *
+ * Lifetime of the MPLS pointer is limited to the lifetime of the BD title
+ */
+struct mpls_pl* bd_get_title_mpls(BLURAY * bd);
 
 #ifdef __cplusplus
 }
diff --git a/src/libbluray/decoders/graphics_controller.c b/src/libbluray/decoders/graphics_controller.c
index dabde1c..d3c775a 100644
--- a/src/libbluray/decoders/graphics_controller.c
+++ b/src/libbluray/decoders/graphics_controller.c
@@ -825,6 +825,8 @@ void gc_free(GRAPHICS_CONTROLLER **p)
 
         bd_mutex_destroy(&gc->mutex);
 
+        X_FREE(gc->saved_bog_data);
+
         X_FREE(*p);
     }
 }
diff --git a/src/libbluray/disc/aacs.c b/src/libbluray/disc/aacs.c
index 3059d66..9ae8efb 100644
--- a/src/libbluray/disc/aacs.c
+++ b/src/libbluray/disc/aacs.c
@@ -47,6 +47,8 @@ struct bd_aacs {
     fptr_p_void    get_device_binding_id;
     fptr_p_void    get_device_nonce;
     fptr_p_void    get_media_key;
+
+    int            impl_id;
 };
 
 
@@ -58,15 +60,19 @@ static void _libaacs_close(BD_AACS *p)
     }
 }
 
-void libaacs_unload(BD_AACS **p)
+static void _unload(BD_AACS *p)
 {
-    if (p && *p) {
-        _libaacs_close(*p);
+    _libaacs_close(p);
 
-        if ((*p)->h_libaacs) {
-            dl_dlclose((*p)->h_libaacs);
-        }
+    if (p->h_libaacs) {
+        dl_dlclose(p->h_libaacs);
+    }
+}
 
+void libaacs_unload(BD_AACS **p)
+{
+    if (p && *p) {
+        _unload(*p);
         X_FREE(*p);
     }
 }
@@ -82,7 +88,7 @@ int libaacs_required(void *have_file_handle, int (*have_file)(void *, const char
     return 0;
 }
 
-static void *_open_libaacs(void)
+static void *_open_libaacs(int *impl_id)
 {
     const char * const libaacs[] = {
       getenv("LIBAACS_PATH"),
@@ -91,10 +97,11 @@ static void *_open_libaacs(void)
     };
     unsigned ii;
 
-    for (ii = 0; ii < sizeof(libaacs) / sizeof(libaacs[0]); ii++) {
+    for (ii = *impl_id; ii < sizeof(libaacs) / sizeof(libaacs[0]); ii++) {
         if (libaacs[ii]) {
             void *handle = dl_dlopen(libaacs[ii], "0");
             if (handle) {
+                *impl_id = ii;
                 BD_DEBUG(DBG_BLURAY, "Using %s for AACS\n", libaacs[ii]);
                 return handle;
             }
@@ -105,14 +112,15 @@ static void *_open_libaacs(void)
     return NULL;
 }
 
-BD_AACS *libaacs_load(void)
+static BD_AACS *_load(int impl_id)
 {
     BD_AACS *p = calloc(1, sizeof(BD_AACS));
     if (!p) {
         return NULL;
     }
+    p->impl_id = impl_id;
 
-    p->h_libaacs = _open_libaacs();
+    p->h_libaacs = _open_libaacs(&p->impl_id);
     if (!p->h_libaacs) {
         X_FREE(p);
         return NULL;
@@ -143,6 +151,11 @@ BD_AACS *libaacs_load(void)
     return p;
 }
 
+BD_AACS *libaacs_load(void)
+{
+    return _load(0);
+}
+
 int libaacs_open(BD_AACS *p, const char *device,
                    void *file_open_handle, void *file_open_fp,
                    const char *keyfile_path)
@@ -180,6 +193,22 @@ int libaacs_open(BD_AACS *p, const char *device,
         BD_DEBUG(DBG_BLURAY, "aacs_open() not found\n");
     }
 
+    if (error_code) {
+        /* failed. try next aacs implementation if available. */
+        BD_AACS *p2 = _load(p->impl_id + 1);
+        if (p2) {
+            if (!libaacs_open(p2, device, file_open_handle, file_open_fp, keyfile_path)) {
+                /* succeed - swap implementations */
+                _unload(p);
+                *p = *p2;
+                X_FREE(p2);
+                return 0;
+            }
+            /* failed - report original errors */
+            libaacs_unload(&p2);
+        }
+    }
+
     if (p->aacs) {
         if (aacs_get_mkb_version) {
             p->mkbv = aacs_get_mkb_version(p->aacs);
diff --git a/src/libbluray/disc/dec.c b/src/libbluray/disc/dec.c
index 290dd4d..1c8a601 100644
--- a/src/libbluray/disc/dec.c
+++ b/src/libbluray/disc/dec.c
@@ -179,6 +179,8 @@ static int _libaacs_init(BD_DEC *dec, struct dec_dev *dev,
     int result;
     const uint8_t *disc_id;
 
+    memset(i, 0, sizeof(*i));
+
     libaacs_unload(&dec->aacs);
 
     i->aacs_detected = libaacs_required((void*)dev, _bdrom_have_file);
@@ -205,7 +207,7 @@ static int _libaacs_init(BD_DEC *dec, struct dec_dev *dev,
     }
 
     if (result) {
-        BD_DEBUG(DBG_BLURAY | DBG_CRIT, "aacs_open() failed!\n");
+        BD_DEBUG(DBG_BLURAY | DBG_CRIT, "aacs_open() failed: %d!\n", result);
         libaacs_unload(&dec->aacs);
         return 0;
     }
@@ -259,6 +261,13 @@ static int _libbdplus_init(BD_DEC *dec, struct dec_dev *dev,
     i->bdplus_gen     = libbdplus_get_gen(dec->bdplus);
     i->bdplus_date    = libbdplus_get_date(dec->bdplus);
     i->bdplus_handled = 1;
+
+    if (i->bdplus_date == 0) {
+        // libmmbd -> no menu support
+        BD_DEBUG(DBG_BLURAY | DBG_CRIT, "WARNING: using libmmbd for BD+. On-disc menus will not work.\n");
+        i->no_menu_support = 1;
+    }
+
     return 1;
 }
 
diff --git a/src/libbluray/disc/disc.c b/src/libbluray/disc/disc.c
index 8f275b8..757b6ed 100644
--- a/src/libbluray/disc/disc.c
+++ b/src/libbluray/disc/disc.c
@@ -69,7 +69,7 @@ static BD_FILE_H *_bdrom_open_path(void *p, const char *rel_path)
         return NULL;
     }
 
-    fp = file_open(abs_path, "rb");
+    fp = file_open(abs_path, "rbS");
     X_FREE(abs_path);
 
     return fp;
@@ -177,7 +177,7 @@ static void _comb_dir_append(BD_DIR_H *dp, BD_DIRENT *entry)
     }
 
     /* append */
-    priv = realloc(priv, sizeof(*priv) + priv->count * sizeof(BD_DIRENT));
+    priv = realloc(dp->internal, sizeof(*priv) + priv->count * sizeof(BD_DIRENT));
     if (!priv) {
         return;
     }
diff --git a/src/libbluray/disc/enc_info.h b/src/libbluray/disc/enc_info.h
index d45d891..47ca94f 100644
--- a/src/libbluray/disc/enc_info.h
+++ b/src/libbluray/disc/enc_info.h
@@ -34,6 +34,8 @@ typedef struct bd_enc_info {
     uint8_t  disc_id[20];
     uint8_t  bdplus_gen;
     uint32_t bdplus_date;
+
+    uint8_t  no_menu_support;
 } BD_ENC_INFO;
 
 #endif /* _BD_DISC_ENC_INFO_H_ */
